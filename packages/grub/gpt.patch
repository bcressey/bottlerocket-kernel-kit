From 9300d0044c1d9e1b8df2784d50a3c26250639ca3 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sun, 28 Sep 2014 21:26:21 -0700
Subject: [PATCH] gpt: start new GPT module

This module is a new implementation for reading GUID Partition Tables
which is much stricter than the existing part_gpt module and exports GPT
data directly instead of the generic grub_partition structure. It will
be the basis for modules that need to read/write/update GPT data.

The current code does nothing more than read and verify the table.
---
 Makefile.util.def            |  16 ++
 grub-core/Makefile.core.def  |   5 +
 grub-core/lib/gpt.c          | 288 ++++++++++++++++++++++++++
 include/grub/gpt_partition.h |  60 ++++++
 tests/gpt_unit_test.c        | 467 +++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 836 insertions(+)
 create mode 100644 grub-core/lib/gpt.c
 create mode 100644 tests/gpt_unit_test.c

diff --git a/Makefile.util.def b/Makefile.util.def
index f9caccb97..48448c28d 100644
--- a/Makefile.util.def
+++ b/Makefile.util.def
@@ -1254,6 +1254,22 @@ program = {
   ldadd = '$(LIBDEVMAPPER) $(LIBZFS) $(LIBNVPAIR) $(LIBGEOM)';
 };
 
+program = {
+  testcase;
+  name = gpt_unit_test;
+  common = tests/gpt_unit_test.c;
+  common = tests/lib/unit_test.c;
+  common = grub-core/disk/host.c;
+  common = grub-core/kern/emu/hostfs.c;
+  common = grub-core/lib/gpt.c;
+  common = grub-core/tests/lib/test.c;
+  ldadd = libgrubmods.a;
+  ldadd = libgrubgcry.a;
+  ldadd = libgrubkern.a;
+  ldadd = grub-core/gnulib/libgnu.a;
+  ldadd = '$(LIBDEVMAPPER) $(LIBZFS) $(LIBNVPAIR) $(LIBGEOM)';
+};
+
 program = {
   name = grub-menulst2cfg;
   mansection = 1;
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 2dfa22a92..d3bcdbe2f 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -821,6 +821,11 @@ module = {
   common = commands/gptsync.c;
 };
 
+module = {
+  name = gpt;
+  common = lib/gpt.c;
+};
+
 module = {
   name = halt;
   nopc = commands/halt.c;
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
new file mode 100644
index 000000000..a308e8537
--- /dev/null
+++ b/grub-core/lib/gpt.c
@@ -0,0 +1,288 @@
+/* gpt.c - Read/Verify/Write GUID Partition Tables (GPT).  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2005,2006,2007,2008  Free Software Foundation, Inc.
+ *  Copyright (C) 2014 CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/crypto.h>
+#include <grub/disk.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/dl.h>
+#include <grub/msdos_partition.h>
+#include <grub/gpt_partition.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_uint8_t grub_gpt_magic[] = GRUB_GPT_HEADER_MAGIC;
+
+
+static grub_err_t
+grub_gpt_header_crc32 (struct grub_gpt_header *gpt, grub_uint32_t *crc)
+{
+  grub_uint8_t *crc32_context;
+  grub_uint32_t old;
+
+  crc32_context = grub_zalloc (GRUB_MD_CRC32->contextsize);
+  if (!crc32_context)
+    return grub_errno;
+
+  /* crc32 must be computed with the field cleared.  */
+  old = gpt->crc32;
+  gpt->crc32 = 0;
+  GRUB_MD_CRC32->init (crc32_context);
+  GRUB_MD_CRC32->write (crc32_context, gpt, sizeof (*gpt));
+  GRUB_MD_CRC32->final (crc32_context);
+  gpt->crc32 = old;
+
+  /* GRUB_MD_CRC32 always uses big endian, gpt is always little.  */
+  *crc = grub_swap_bytes32 (*(grub_uint32_t *)
+			    GRUB_MD_CRC32->read (crc32_context));
+
+  grub_free (crc32_context);
+
+  return GRUB_ERR_NONE;
+}
+
+/* Make sure the MBR is a protective MBR and not a normal MBR.  */
+grub_err_t
+grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr)
+{
+  unsigned int i;
+
+  if (mbr->signature !=
+      grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid MBR signature");
+
+  for (i = 0; i < sizeof (mbr->entries); i++)
+    if (mbr->entries[i].type == GRUB_PC_PARTITION_TYPE_GPT_DISK)
+      return GRUB_ERR_NONE;
+
+  return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid protective MBR");
+}
+
+grub_err_t
+grub_gpt_header_check (struct grub_gpt_header *gpt,
+		       unsigned int log_sector_size)
+{
+  grub_uint32_t crc = 0, size;
+
+  if (grub_memcmp (gpt->magic, grub_gpt_magic, sizeof (grub_gpt_magic)) != 0)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT signature");
+
+  if (gpt->version != GRUB_GPT_HEADER_VERSION)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "unknown GPT version");
+
+  if (grub_gpt_header_crc32 (gpt, &crc))
+    return grub_errno;
+
+  if (gpt->crc32 != crc)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header crc32");
+
+  /* The header size must be between 92 and the sector size.  */
+  size = grub_le_to_cpu32 (gpt->headersize);
+  if (size < 92U || size > (1U << log_sector_size))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header size");
+
+  /* The partition entry size must be a multiple of 128.  */
+  size = grub_le_to_cpu32 (gpt->partentry_size);
+  if (size < 128 || size % 128)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry size");
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_primary (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_disk_addr_t addr;
+
+  /* TODO: The gpt partmap module searches for the primary header instead
+   * of relying on the disk's sector size. For now trust the disk driver
+   * but eventually this code should match the existing behavior.  */
+  gpt->log_sector_size = disk->log_sector_size;
+
+  addr = grub_gpt_sector_to_addr (gpt, 1);
+  if (grub_disk_read (disk, addr, 0, sizeof (gpt->primary), &gpt->primary))
+    return grub_errno;
+
+  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+    return grub_errno;
+
+  gpt->status |= GRUB_GPT_PRIMARY_HEADER_VALID;
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_uint64_t sector;
+  grub_disk_addr_t addr;
+
+  /* Assumes gpt->log_sector_size == disk->log_sector_size  */
+  if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN)
+    sector = disk->total_sectors - 1;
+  else if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    sector = grub_le_to_cpu64 (gpt->primary.backup);
+  else
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "Unable to locate backup GPT");
+
+  addr = grub_gpt_sector_to_addr (gpt, sector);
+  if (grub_disk_read (disk, addr, 0, sizeof (gpt->backup), &gpt->backup))
+    return grub_errno;
+
+  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+    return grub_errno;
+
+  gpt->status |= GRUB_GPT_BACKUP_HEADER_VALID;
+  return GRUB_ERR_NONE;
+}
+
+static struct grub_gpt_partentry *
+grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
+		       struct grub_gpt_header *header)
+{
+  struct grub_gpt_partentry *entries = NULL;
+  grub_uint8_t *crc32_context = NULL;
+  grub_uint32_t count, size, crc;
+  grub_disk_addr_t addr;
+  grub_size_t entries_size;
+
+  /* Grub doesn't include calloc, hence the manual overflow check.  */
+  count = grub_le_to_cpu32 (header->maxpart);
+  size = grub_le_to_cpu32 (header->partentry_size);
+  entries_size = count *size;
+  if (size && entries_size / size != count)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+      goto fail;
+    }
+
+  entries = grub_malloc (entries_size);
+  if (!entries)
+    goto fail;
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->partitions));
+  if (grub_disk_read (disk, addr, 0, entries_size, entries))
+    goto fail;
+
+  crc32_context = grub_zalloc (GRUB_MD_CRC32->contextsize);
+  if (!crc32_context)
+    goto fail;
+
+  GRUB_MD_CRC32->init (crc32_context);
+  GRUB_MD_CRC32->write (crc32_context, entries, entries_size);
+  GRUB_MD_CRC32->final (crc32_context);
+
+  crc = *(grub_uint32_t *) GRUB_MD_CRC32->read (crc32_context);
+  if (grub_swap_bytes32 (crc) != header->partentry_crc32)
+    {
+      grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry crc32");
+      goto fail;
+    }
+
+  grub_free (crc32_context);
+  return entries;
+
+fail:
+  grub_free (entries);
+  grub_free (crc32_context);
+  return NULL;
+}
+
+grub_gpt_t
+grub_gpt_read (grub_disk_t disk)
+{
+  grub_gpt_t gpt;
+  struct grub_gpt_partentry *backup_entries;
+
+  gpt = grub_zalloc (sizeof (*gpt));
+  if (!gpt)
+    goto fail;
+
+  if (grub_disk_read (disk, 0, 0, sizeof (gpt->mbr), &gpt->mbr))
+    goto fail;
+
+  /* Check the MBR but errors aren't reported beyond the status bit.  */
+  if (grub_gpt_pmbr_check (&gpt->mbr))
+    grub_errno = GRUB_ERR_NONE;
+  else
+    gpt->status |= GRUB_GPT_PROTECTIVE_MBR;
+
+  /* If both the primary and backup fail report the primary's error.  */
+  if (grub_gpt_read_primary (disk, gpt))
+    {
+      grub_error_push ();
+      grub_gpt_read_backup (disk, gpt);
+      grub_error_pop ();
+    }
+  else
+    grub_gpt_read_backup (disk, gpt);
+
+  /* If either succeeded clear any possible error from the other.  */
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID ||
+      gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    grub_errno = GRUB_ERR_NONE;
+  else
+    goto fail;
+
+  /* Same error handling scheme for the entry tables.  */
+  gpt->entries = grub_gpt_read_entries (disk, gpt, &gpt->primary);
+  if (!gpt->entries)
+    {
+      grub_error_push ();
+      backup_entries = grub_gpt_read_entries (disk, gpt, &gpt->backup);
+      grub_error_pop ();
+    }
+  else
+    {
+      gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
+      backup_entries = grub_gpt_read_entries (disk, gpt, &gpt->backup);
+    }
+
+  if (backup_entries)
+    {
+      gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
+
+      if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID)
+	grub_free (backup_entries);
+      else
+	gpt->entries = backup_entries;
+    }
+
+  if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
+      gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID)
+    {
+      grub_errno = GRUB_ERR_NONE;
+      return gpt;
+    }
+
+fail:
+  grub_gpt_free (gpt);
+  return NULL;
+}
+
+void
+grub_gpt_free (grub_gpt_t gpt)
+{
+  if (!gpt)
+    return;
+
+  grub_free (gpt->entries);
+  grub_free (gpt);
+}
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 1b32f6725..04ed2d7f1 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -21,6 +21,7 @@
 
 #include <grub/types.h>
 #include <grub/partition.h>
+#include <grub/msdos_partition.h>
 
 struct grub_gpt_part_type
 {
@@ -50,6 +51,12 @@ typedef struct grub_gpt_part_type grub_gpt_part_type_t;
 	{ 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3 }	\
   }
 
+#define GRUB_GPT_HEADER_MAGIC \
+  { 0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54 }
+
+#define GRUB_GPT_HEADER_VERSION	\
+  grub_cpu_to_le32_compile_time (0x00010000U)
+
 struct grub_gpt_header
 {
   grub_uint8_t magic[8];
@@ -78,10 +85,63 @@ struct grub_gpt_partentry
   char name[72];
 } GRUB_PACKED;
 
+/* Basic GPT partmap module.  */
 grub_err_t
 grub_gpt_partition_map_iterate (grub_disk_t disk,
 				grub_partition_iterate_hook_t hook,
 				void *hook_data);
 
+/* Advanced GPT library.  */
+typedef enum grub_gpt_status
+  {
+    GRUB_GPT_PROTECTIVE_MBR         = 0x01,
+    GRUB_GPT_HYBRID_MBR             = 0x02,
+    GRUB_GPT_PRIMARY_HEADER_VALID   = 0x04,
+    GRUB_GPT_PRIMARY_ENTRIES_VALID  = 0x08,
+    GRUB_GPT_BACKUP_HEADER_VALID    = 0x10,
+    GRUB_GPT_BACKUP_ENTRIES_VALID   = 0x20,
+  } grub_gpt_status_t;
+
+#define GRUB_GPT_MBR_VALID (GRUB_GPT_PROTECTIVE_MBR|GRUB_GPT_HYBRID_MBR)
+
+/* UEFI requires the entries table to be at least 16384 bytes for a
+ * total of 128 entries given the standard 128 byte entry size.  */
+#define GRUB_GPT_DEFAULT_ENTRIES_LENGTH	128
+
+struct grub_gpt
+{
+  /* Bit field indicating which structures on disk are valid.  */
+  grub_gpt_status_t status;
+
+  /* Protective or hybrid MBR.  */
+  struct grub_msdos_partition_mbr mbr;
+
+  /* Each of the two GPT headers.  */
+  struct grub_gpt_header primary;
+  struct grub_gpt_header backup;
+
+  /* Only need one entries table, on disk both copies are identical.  */
+  struct grub_gpt_partentry *entries;
+
+  /* Logarithm of sector size, in case GPT and disk driver disagree.  */
+  unsigned int log_sector_size;
+};
+typedef struct grub_gpt *grub_gpt_t;
+
+/* Translate GPT sectors to GRUB's 512 byte block addresses.  */
+static inline grub_disk_addr_t
+grub_gpt_sector_to_addr (grub_gpt_t gpt, grub_uint64_t sector)
+{
+  return (sector << (gpt->log_sector_size - GRUB_DISK_SECTOR_BITS));
+}
+
+/* Allocates and fills new grub_gpt structure, free with grub_gpt_free.  */
+grub_gpt_t grub_gpt_read (grub_disk_t disk);
+
+void grub_gpt_free (grub_gpt_t gpt);
+
+grub_err_t grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr);
+grub_err_t grub_gpt_header_check (struct grub_gpt_header *gpt,
+				  unsigned int log_sector_size);
 
 #endif /* ! GRUB_GPT_PARTITION_HEADER */
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
new file mode 100644
index 000000000..a824cd967
--- /dev/null
+++ b/tests/gpt_unit_test.c
@@ -0,0 +1,467 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2014 CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/command.h>
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/emu/hostdisk.h>
+#include <grub/emu/misc.h>
+#include <grub/err.h>
+#include <grub/gpt_partition.h>
+#include <grub/msdos_partition.h>
+#include <grub/test.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+/* from gnulib */
+#include <verify.h>
+
+
+/* GPT section sizes.  */
+#define HEADER_SIZE   (sizeof (struct grub_gpt_header))
+#define HEADER_PAD    (GRUB_DISK_SECTOR_SIZE - HEADER_SIZE)
+#define ENTRY_SIZE    (sizeof (struct grub_gpt_partentry))
+#define TABLE_ENTRIES 0x80
+#define TABLE_SIZE    (TABLE_ENTRIES * ENTRY_SIZE)
+#define TABLE_SECTORS (TABLE_SIZE / GRUB_DISK_SECTOR_SIZE)
+
+/* Double check that the table size calculation was valid.  */
+verify (TABLE_SECTORS * GRUB_DISK_SECTOR_SIZE == TABLE_SIZE);
+
+/* GPT section locations for a 1MiB disk.  */
+#define DISK_SECTORS	      0x800
+#define DISK_SIZE	      (GRUB_DISK_SECTOR_SIZE * DISK_SECTORS)
+#define PRIMARY_HEADER_SECTOR 0x1
+#define PRIMARY_TABLE_SECTOR  0x2
+#define BACKUP_HEADER_SECTOR  (DISK_SECTORS - 0x1)
+#define BACKUP_TABLE_SECTOR   (BACKUP_HEADER_SECTOR - TABLE_SECTORS)
+
+#define DATA_START_SECTOR     (PRIMARY_TABLE_SECTOR + TABLE_SECTORS)
+#define DATA_END_SECTOR	      (BACKUP_TABLE_SECTOR - 0x1)
+#define DATA_SECTORS	      (BACKUP_TABLE_SECTOR - DATA_START_SECTOR)
+#define DATA_SIZE	      (GRUB_DISK_SECTOR_SIZE * DATA_SECTORS)
+
+struct test_disk
+{
+  struct grub_msdos_partition_mbr mbr;
+
+  struct grub_gpt_header primary_header;
+  grub_uint8_t primary_header_pad[HEADER_PAD];
+  struct grub_gpt_partentry primary_entries[TABLE_ENTRIES];
+
+  grub_uint8_t data[DATA_SIZE];
+
+  struct grub_gpt_partentry backup_entries[TABLE_ENTRIES];
+  struct grub_gpt_header backup_header;
+  grub_uint8_t backup_header_pad[HEADER_PAD];
+} GRUB_PACKED;
+
+/* Sanity check that all the above ugly math was correct.  */
+verify (sizeof (struct test_disk) == DISK_SIZE);
+
+struct test_data
+{
+  int fd;
+  grub_device_t dev;
+  struct test_disk *raw;
+};
+
+
+/* Sample primary GPT header for an empty 1MB disk.  */
+static const struct grub_gpt_header example_primary = {
+  .magic = GRUB_GPT_HEADER_MAGIC,
+  .version = GRUB_GPT_HEADER_VERSION,
+  .headersize = sizeof (struct grub_gpt_header),
+  .crc32 = grub_cpu_to_le32_compile_time (0x7cd8642c),
+  .primary = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+  .backup = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+  .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+  .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
+  .guid = {0xad, 0x31, 0xc1, 0x69, 0xd6, 0x67, 0xc6, 0x46,
+	   0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac},
+  .partitions = grub_cpu_to_le64_compile_time (PRIMARY_TABLE_SECTOR),
+  .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
+  .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
+  .partentry_crc32 = grub_cpu_to_le32_compile_time (0xab54d286),
+};
+
+/* And the backup header.  */
+static const struct grub_gpt_header example_backup = {
+  .magic = GRUB_GPT_HEADER_MAGIC,
+  .version = GRUB_GPT_HEADER_VERSION,
+  .headersize = sizeof (struct grub_gpt_header),
+  .crc32 = grub_cpu_to_le32_compile_time (0xcfaa4a27),
+  .primary = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+  .backup = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+  .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+  .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
+  .guid = {0xad, 0x31, 0xc1, 0x69, 0xd6, 0x67, 0xc6, 0x46,
+	   0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac},
+  .partitions = grub_cpu_to_le64_compile_time (BACKUP_TABLE_SECTOR),
+  .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
+  .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
+  .partentry_crc32 = grub_cpu_to_le32_compile_time (0xab54d286),
+};
+
+/* Sample protective MBR for the same 1MB disk. Note, this matches
+ * parted and fdisk behavior. The UEFI spec uses different values.  */
+static const struct grub_msdos_partition_mbr example_pmbr = {
+  .entries = {{.flag = 0x00,
+	       .start_head = 0x00,
+	       .start_sector = 0x01,
+	       .start_cylinder = 0x00,
+	       .type = 0xee,
+	       .end_head = 0xfe,
+	       .end_sector = 0xff,
+	       .end_cylinder = 0xff,
+	       .start = grub_cpu_to_le32_compile_time (0x1),
+	       .length = grub_cpu_to_le32_compile_time (DISK_SECTORS - 0x1),
+	       }},
+  .signature = grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE),
+};
+
+/* If errors are left in grub's error stack things can get confused.  */
+static void
+assert_error_stack_empty (void)
+{
+  do
+    {
+      grub_test_assert (grub_errno == GRUB_ERR_NONE,
+			"error on stack: %s", grub_errmsg);
+    }
+  while (grub_error_pop ());
+}
+
+static grub_err_t
+execute_command2 (const char *name, const char *arg1, const char *arg2)
+{
+  grub_command_t cmd;
+  grub_err_t err;
+  char *argv[2];
+
+  cmd = grub_command_find (name);
+  if (!cmd)
+    grub_fatal ("can't find command %s", name);
+
+  argv[0] = strdup (arg1);
+  argv[1] = strdup (arg2);
+  err = (cmd->func) (cmd, 2, argv);
+  free (argv[0]);
+  free (argv[1]);
+
+  return err;
+}
+
+static void
+sync_disk (struct test_data *data)
+{
+  if (msync (data->raw, DISK_SIZE, MS_SYNC | MS_INVALIDATE) < 0)
+    grub_fatal ("Syncing disk failed: %s", strerror (errno));
+
+  grub_disk_cache_invalidate_all ();
+}
+
+static void
+reset_disk (struct test_data *data)
+{
+  memset (data->raw, 0, DISK_SIZE);
+
+  /* Initialize image with valid example tables.  */
+  memcpy (&data->raw->mbr, &example_pmbr, sizeof (data->raw->mbr));
+  memcpy (&data->raw->primary_header, &example_primary,
+	  sizeof (data->raw->primary_header));
+  memcpy (&data->raw->backup_header, &example_backup,
+	  sizeof (data->raw->backup_header));
+
+  sync_disk (data);
+}
+
+static void
+open_disk (struct test_data *data)
+{
+  const char *loop = "loop0";
+  char template[] = "/tmp/grub_gpt_test.XXXXXX";
+  char host[sizeof ("(host)") + sizeof (template)];
+
+  data->fd = mkstemp (template);
+  if (data->fd < 0)
+    grub_fatal ("Creating %s failed: %s", template, strerror (errno));
+
+  if (ftruncate (data->fd, DISK_SIZE) < 0)
+    {
+      int err = errno;
+      unlink (template);
+      grub_fatal ("Resizing %s failed: %s", template, strerror (err));
+    }
+
+  data->raw = mmap (NULL, DISK_SIZE, PROT_READ | PROT_WRITE,
+		    MAP_SHARED, data->fd, 0);
+  if (data->raw == MAP_FAILED)
+    {
+      int err = errno;
+      unlink (template);
+      grub_fatal ("Maping %s failed: %s", template, strerror (err));
+    }
+
+  snprintf (host, sizeof (host), "(host)%s", template);
+  if (execute_command2 ("loopback", loop, host) != GRUB_ERR_NONE)
+    {
+      unlink (template);
+      grub_fatal ("loopback %s %s failed: %s", loop, host, grub_errmsg);
+    }
+
+  if (unlink (template) < 0)
+    grub_fatal ("Unlinking %s failed: %s", template, strerror (errno));
+
+  reset_disk (data);
+
+  data->dev = grub_device_open (loop);
+  if (!data->dev)
+    grub_fatal ("Opening %s failed: %s", loop, grub_errmsg);
+}
+
+static void
+close_disk (struct test_data *data)
+{
+  char *loop;
+
+  assert_error_stack_empty ();
+
+  if (munmap (data->raw, DISK_SIZE) || close (data->fd))
+    grub_fatal ("Closing disk image failed: %s", strerror (errno));
+
+  loop = strdup (data->dev->disk->name);
+  grub_test_assert (grub_device_close (data->dev) == GRUB_ERR_NONE,
+		    "Closing disk device failed: %s", grub_errmsg);
+
+  grub_test_assert (execute_command2 ("loopback", "-d", loop) ==
+		    GRUB_ERR_NONE, "loopback -d %s failed: %s", loop,
+		    grub_errmsg);
+
+  free (loop);
+}
+
+static grub_gpt_t
+read_disk (struct test_data *data)
+{
+  grub_gpt_t gpt;
+
+  gpt = grub_gpt_read (data->dev->disk);
+  if (gpt == NULL)
+    {
+      grub_print_error ();
+      grub_fatal ("grub_gpt_read failed");
+    }
+
+
+  return gpt;
+}
+
+static void
+pmbr_test (void)
+{
+  struct grub_msdos_partition_mbr mbr;
+
+  memset (&mbr, 0, sizeof (mbr));
+
+  /* Empty is invalid.  */
+  grub_gpt_pmbr_check (&mbr);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  /* A table without a protective partition is invalid.  */
+  mbr.signature = grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE);
+  grub_gpt_pmbr_check (&mbr);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  /* A table with a protective type is ok.  */
+  memcpy (&mbr, &example_pmbr, sizeof (mbr));
+  grub_gpt_pmbr_check (&mbr);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+}
+
+static void
+header_test (void)
+{
+  struct grub_gpt_header primary, backup;
+
+  /* Example headers should be valid.  */
+  memcpy (&primary, &example_primary, sizeof (primary));
+  grub_gpt_header_check (&primary, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  memcpy (&backup, &example_backup, sizeof (backup));
+  grub_gpt_header_check (&backup, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  /* Twiddle the GUID to invalidate the CRC. */
+  primary.guid[0] = 0;
+  grub_gpt_header_check (&primary, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  backup.guid[0] = 0;
+  grub_gpt_header_check (&backup, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+}
+
+static void
+read_valid_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert (gpt->status == (GRUB_GPT_PROTECTIVE_MBR |
+				    GRUB_GPT_PRIMARY_HEADER_VALID |
+				    GRUB_GPT_PRIMARY_ENTRIES_VALID |
+				    GRUB_GPT_BACKUP_HEADER_VALID |
+				    GRUB_GPT_BACKUP_ENTRIES_VALID),
+		    "unexpected status: 0x%02x", gpt->status);
+  grub_gpt_free (gpt);
+  close_disk (&data);
+}
+
+static void
+read_invalid_entries_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Corrupt the first entry in both tables.  */
+  memset (&data.raw->primary_entries[0], 0x55,
+	  sizeof (data.raw->primary_entries[0]));
+  memset (&data.raw->backup_entries[0], 0x55,
+	  sizeof (data.raw->backup_entries[0]));
+  sync_disk (&data);
+
+  gpt = grub_gpt_read (data.dev->disk);
+  grub_test_assert (gpt == NULL, "no error reported for corrupt entries");
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
+static void
+read_fallback_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Corrupt the primary header.  */
+  memset (&data.raw->primary_header.guid, 0x55,
+	  sizeof (data.raw->primary_header.guid));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) == 0,
+		    "unreported corrupt primary header");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Corrupt the backup header.  */
+  memset (&data.raw->backup_header.guid, 0x55,
+	  sizeof (data.raw->backup_header.guid));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_BACKUP_HEADER_VALID) == 0,
+		    "unreported corrupt backup header");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Corrupt the primary entry table.  */
+  memset (&data.raw->primary_entries[0], 0x55,
+	  sizeof (data.raw->primary_entries[0]));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID) == 0,
+		    "unreported corrupt primary entries table");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Corrupt the backup entry table.  */
+  memset (&data.raw->backup_entries[0], 0x55,
+	  sizeof (data.raw->backup_entries[0]));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID) == 0,
+		    "unreported corrupt backup entries table");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* If primary is corrupt and disk size is unknown fallback fails.  */
+  memset (&data.raw->primary_header.guid, 0x55,
+	  sizeof (data.raw->primary_header.guid));
+  sync_disk (&data);
+  data.dev->disk->total_sectors = GRUB_DISK_SIZE_UNKNOWN;
+  gpt = grub_gpt_read (data.dev->disk);
+  grub_test_assert (gpt == NULL, "no error reported");
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
+void
+grub_unit_test_init (void)
+{
+  grub_init_all ();
+  grub_hostfs_init ();
+  grub_host_init ();
+  grub_test_register ("gpt_pmbr_test", pmbr_test);
+  grub_test_register ("gpt_header_test", header_test);
+  grub_test_register ("gpt_read_valid_test", read_valid_test);
+  grub_test_register ("gpt_read_invalid_test", read_invalid_entries_test);
+  grub_test_register ("gpt_read_fallback_test", read_fallback_test);
+}
+
+void
+grub_unit_test_fini (void)
+{
+  grub_test_unregister ("gpt_pmbr_test");
+  grub_test_unregister ("gpt_header_test");
+  grub_test_unregister ("gpt_read_valid_test");
+  grub_test_unregister ("gpt_read_invalid_test");
+  grub_test_unregister ("gpt_read_fallback_test");
+  grub_fini_all ();
+}
From 91a8986e53926bc0a94f251a9b4fe8974af75020 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sat, 18 Oct 2014 15:39:13 -0700
Subject: [PATCH] gpt: rename misnamed header location fields

The header location fields refer to 'this header' and 'alternate header'
respectively, not 'primary header' and 'backup header'. The previous
field names are backwards for the backup header.
---
 grub-core/lib/gpt.c          | 2 +-
 include/grub/gpt_partition.h | 4 ++--
 tests/gpt_unit_test.c        | 8 ++++----
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index a308e8537..705bd77f9 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -137,7 +137,7 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
   if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN)
     sector = disk->total_sectors - 1;
   else if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
-    sector = grub_le_to_cpu64 (gpt->primary.backup);
+    sector = grub_le_to_cpu64 (gpt->primary.alternate_lba);
   else
     return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 		       "Unable to locate backup GPT");
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 04ed2d7f1..a7ef61875 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -64,8 +64,8 @@ struct grub_gpt_header
   grub_uint32_t headersize;
   grub_uint32_t crc32;
   grub_uint32_t unused1;
-  grub_uint64_t primary;
-  grub_uint64_t backup;
+  grub_uint64_t header_lba;
+  grub_uint64_t alternate_lba;
   grub_uint64_t start;
   grub_uint64_t end;
   grub_uint8_t guid[16];
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index a824cd967..4d70868af 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -94,8 +94,8 @@ static const struct grub_gpt_header example_primary = {
   .version = GRUB_GPT_HEADER_VERSION,
   .headersize = sizeof (struct grub_gpt_header),
   .crc32 = grub_cpu_to_le32_compile_time (0x7cd8642c),
-  .primary = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
-  .backup = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+  .header_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+  .alternate_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
   .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
   .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
   .guid = {0xad, 0x31, 0xc1, 0x69, 0xd6, 0x67, 0xc6, 0x46,
@@ -112,8 +112,8 @@ static const struct grub_gpt_header example_backup = {
   .version = GRUB_GPT_HEADER_VERSION,
   .headersize = sizeof (struct grub_gpt_header),
   .crc32 = grub_cpu_to_le32_compile_time (0xcfaa4a27),
-  .primary = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
-  .backup = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+  .header_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+  .alternate_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
   .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
   .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
   .guid = {0xad, 0x31, 0xc1, 0x69, 0xd6, 0x67, 0xc6, 0x46,
From 23e0197ea4561fc3a9e59c1af9bf2357d21e1b52 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sat, 18 Oct 2014 16:46:17 -0700
Subject: [PATCH] gpt: record size of of the entries table

The size of the entries table will be needed later when writing it back
to disk. Restructure the entries reading code to flow a little better.
---
 grub-core/lib/gpt.c          | 53 +++++++++++++++++++-------------------------
 include/grub/gpt_partition.h |  5 ++++-
 2 files changed, 27 insertions(+), 31 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 705bd77f9..01df7f3e8 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -153,7 +153,7 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
   return GRUB_ERR_NONE;
 }
 
-static struct grub_gpt_partentry *
+static grub_err_t
 grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
 		       struct grub_gpt_header *header)
 {
@@ -173,6 +173,10 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
       goto fail;
     }
 
+  /* Double check that the header was validated properly.  */
+  if (entries_size < GRUB_GPT_DEFAULT_ENTRIES_SIZE)
+    return grub_error (GRUB_ERR_BUG, "invalid GPT entries table size");
+
   entries = grub_malloc (entries_size);
   if (!entries)
     goto fail;
@@ -197,19 +201,21 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
     }
 
   grub_free (crc32_context);
-  return entries;
+  grub_free (gpt->entries);
+  gpt->entries = entries;
+  gpt->entries_size = entries_size;
+  return GRUB_ERR_NONE;
 
 fail:
   grub_free (entries);
   grub_free (crc32_context);
-  return NULL;
+  return grub_errno;
 }
 
 grub_gpt_t
 grub_gpt_read (grub_disk_t disk)
 {
   grub_gpt_t gpt;
-  struct grub_gpt_partentry *backup_entries;
 
   gpt = grub_zalloc (sizeof (*gpt));
   if (!gpt)
@@ -241,36 +247,23 @@ grub_gpt_read (grub_disk_t disk)
   else
     goto fail;
 
-  /* Same error handling scheme for the entry tables.  */
-  gpt->entries = grub_gpt_read_entries (disk, gpt, &gpt->primary);
-  if (!gpt->entries)
-    {
-      grub_error_push ();
-      backup_entries = grub_gpt_read_entries (disk, gpt, &gpt->backup);
-      grub_error_pop ();
-    }
-  else
-    {
-      gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
-      backup_entries = grub_gpt_read_entries (disk, gpt, &gpt->backup);
-    }
+  /* Similarly, favor the value or error from the primary table.  */
+  if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID &&
+      !grub_gpt_read_entries (disk, gpt, &gpt->backup))
+    gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
 
-  if (backup_entries)
-    {
-      gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
-
-      if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID)
-	grub_free (backup_entries);
-      else
-	gpt->entries = backup_entries;
-    }
+  grub_errno = GRUB_ERR_NONE;
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID &&
+      !grub_gpt_read_entries (disk, gpt, &gpt->primary))
+    gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
 
   if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
       gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID)
-    {
-      grub_errno = GRUB_ERR_NONE;
-      return gpt;
-    }
+    grub_errno = GRUB_ERR_NONE;
+  else
+    goto fail;
+
+  return gpt;
 
 fail:
   grub_gpt_free (gpt);
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index a7ef61875..7f41e22dd 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -106,7 +106,9 @@ typedef enum grub_gpt_status
 
 /* UEFI requires the entries table to be at least 16384 bytes for a
  * total of 128 entries given the standard 128 byte entry size.  */
-#define GRUB_GPT_DEFAULT_ENTRIES_LENGTH	128
+#define GRUB_GPT_DEFAULT_ENTRIES_SIZE	16384
+#define GRUB_GPT_DEFAULT_ENTRIES_LENGTH	\
+  (GRUB_GPT_DEFAULT_ENTRIES_SIZE / sizeof (struct grub_gpt_partentry))
 
 struct grub_gpt
 {
@@ -122,6 +124,7 @@ struct grub_gpt
 
   /* Only need one entries table, on disk both copies are identical.  */
   struct grub_gpt_partentry *entries;
+  grub_size_t entries_size;
 
   /* Logarithm of sector size, in case GPT and disk driver disagree.  */
   unsigned int log_sector_size;
From 187c377743b26d8fcf44ea3e5ac1ae6edf92ab23 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sat, 18 Oct 2014 18:18:17 -0700
Subject: [PATCH] gpt: consolidate crc32 computation code

The gcrypt API is overly verbose, wrap it up in a helper function to
keep this rather common operation easy to use.
---
 grub-core/lib/gpt.c | 43 ++++++++++++++++++++++++-------------------
 1 file changed, 24 insertions(+), 19 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 01df7f3e8..43a150942 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -32,22 +32,17 @@ static grub_uint8_t grub_gpt_magic[] = GRUB_GPT_HEADER_MAGIC;
 
 
 static grub_err_t
-grub_gpt_header_crc32 (struct grub_gpt_header *gpt, grub_uint32_t *crc)
+grub_gpt_lecrc32 (void *data, grub_size_t len, grub_uint32_t *crc)
 {
   grub_uint8_t *crc32_context;
-  grub_uint32_t old;
 
   crc32_context = grub_zalloc (GRUB_MD_CRC32->contextsize);
   if (!crc32_context)
     return grub_errno;
 
-  /* crc32 must be computed with the field cleared.  */
-  old = gpt->crc32;
-  gpt->crc32 = 0;
   GRUB_MD_CRC32->init (crc32_context);
-  GRUB_MD_CRC32->write (crc32_context, gpt, sizeof (*gpt));
+  GRUB_MD_CRC32->write (crc32_context, data, len);
   GRUB_MD_CRC32->final (crc32_context);
-  gpt->crc32 = old;
 
   /* GRUB_MD_CRC32 always uses big endian, gpt is always little.  */
   *crc = grub_swap_bytes32 (*(grub_uint32_t *)
@@ -58,6 +53,25 @@ grub_gpt_header_crc32 (struct grub_gpt_header *gpt, grub_uint32_t *crc)
   return GRUB_ERR_NONE;
 }
 
+static grub_err_t
+grub_gpt_header_lecrc32 (struct grub_gpt_header *header, grub_uint32_t *crc)
+{
+  grub_uint32_t old, new;
+  grub_err_t err;
+
+  /* crc32 must be computed with the field cleared.  */
+  old = header->crc32;
+  header->crc32 = 0;
+  err = grub_gpt_lecrc32 (header, sizeof (*header), &new);
+  header->crc32 = old;
+
+  if (err)
+    return err;
+
+  *crc = new;
+  return GRUB_ERR_NONE;
+}
+
 /* Make sure the MBR is a protective MBR and not a normal MBR.  */
 grub_err_t
 grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr)
@@ -87,7 +101,7 @@ grub_gpt_header_check (struct grub_gpt_header *gpt,
   if (gpt->version != GRUB_GPT_HEADER_VERSION)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "unknown GPT version");
 
-  if (grub_gpt_header_crc32 (gpt, &crc))
+  if (grub_gpt_header_lecrc32 (gpt, &crc))
     return grub_errno;
 
   if (gpt->crc32 != crc)
@@ -158,7 +172,6 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
 		       struct grub_gpt_header *header)
 {
   struct grub_gpt_partentry *entries = NULL;
-  grub_uint8_t *crc32_context = NULL;
   grub_uint32_t count, size, crc;
   grub_disk_addr_t addr;
   grub_size_t entries_size;
@@ -185,22 +198,15 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
   if (grub_disk_read (disk, addr, 0, entries_size, entries))
     goto fail;
 
-  crc32_context = grub_zalloc (GRUB_MD_CRC32->contextsize);
-  if (!crc32_context)
+  if (grub_gpt_lecrc32 (entries, entries_size, &crc))
     goto fail;
 
-  GRUB_MD_CRC32->init (crc32_context);
-  GRUB_MD_CRC32->write (crc32_context, entries, entries_size);
-  GRUB_MD_CRC32->final (crc32_context);
-
-  crc = *(grub_uint32_t *) GRUB_MD_CRC32->read (crc32_context);
-  if (grub_swap_bytes32 (crc) != header->partentry_crc32)
+  if (crc != header->partentry_crc32)
     {
       grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry crc32");
       goto fail;
     }
 
-  grub_free (crc32_context);
   grub_free (gpt->entries);
   gpt->entries = entries;
   gpt->entries_size = entries_size;
@@ -208,7 +214,6 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
 
 fail:
   grub_free (entries);
-  grub_free (crc32_context);
   return grub_errno;
 }
 
From f6e8fc02aa5f5ed02e529e2b30a94b0589d30e31 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sat, 18 Oct 2014 18:21:07 -0700
Subject: [PATCH] gpt: add new repair function to sync up primary and backup
 tables.

---
 grub-core/lib/gpt.c          | 90 ++++++++++++++++++++++++++++++++++++++++++++
 include/grub/gpt_partition.h |  3 ++
 tests/gpt_unit_test.c        | 49 ++++++++++++++++++++++++
 3 files changed, 142 insertions(+)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 43a150942..2d61df488 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -31,6 +31,20 @@ GRUB_MOD_LICENSE ("GPLv3+");
 static grub_uint8_t grub_gpt_magic[] = GRUB_GPT_HEADER_MAGIC;
 
 
+static grub_uint64_t
+grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
+{
+  unsigned int sector_size;
+  grub_uint64_t sectors;
+
+  sector_size = 1U << gpt->log_sector_size;
+  sectors = size / sector_size;
+  if (size % sector_size)
+    sectors++;
+
+  return sectors;
+}
+
 static grub_err_t
 grub_gpt_lecrc32 (void *data, grub_size_t len, grub_uint32_t *crc)
 {
@@ -275,6 +289,82 @@ fail:
   return NULL;
 }
 
+grub_err_t
+grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_uint64_t backup_header, backup_entries;
+  grub_uint32_t crc;
+
+  if (disk->log_sector_size != gpt->log_sector_size)
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "GPT sector size must match disk sector size");
+
+  if (!(gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
+        gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID))
+    return grub_error (GRUB_ERR_BUG, "No valid GPT entries");
+
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    {
+      backup_header = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+      grub_memcpy (&gpt->backup, &gpt->primary, sizeof (gpt->backup));
+    }
+  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    {
+      backup_header = grub_le_to_cpu64 (gpt->backup.header_lba);
+      grub_memcpy (&gpt->primary, &gpt->backup, sizeof (gpt->primary));
+    }
+  else
+    return grub_error (GRUB_ERR_BUG, "No valid GPT header");
+
+  /* Relocate backup to end if disk whenever possible.  */
+  if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN)
+    backup_header = disk->total_sectors - 1;
+
+  backup_entries = backup_header -
+    grub_gpt_size_to_sectors (gpt, gpt->entries_size);
+
+  /* Update/fixup header and partition table locations.  */
+  gpt->primary.header_lba = grub_cpu_to_le64_compile_time (1);
+  gpt->primary.alternate_lba = grub_cpu_to_le64 (backup_header);
+  gpt->primary.partitions = grub_cpu_to_le64_compile_time (2);
+  gpt->backup.header_lba = gpt->primary.alternate_lba;
+  gpt->backup.alternate_lba = gpt->primary.header_lba;
+  gpt->backup.partitions = grub_cpu_to_le64 (backup_entries);
+
+  /* Writing headers larger than our header structure are unsupported.  */
+  gpt->primary.headersize =
+    grub_cpu_to_le32_compile_time (sizeof (gpt->primary));
+  gpt->backup.headersize =
+    grub_cpu_to_le32_compile_time (sizeof (gpt->backup));
+
+  /* Recompute checksums.  */
+  if (grub_gpt_lecrc32 (gpt->entries, gpt->entries_size, &crc))
+    return grub_errno;
+
+  gpt->primary.partentry_crc32 = crc;
+  gpt->backup.partentry_crc32 = crc;
+
+  if (grub_gpt_header_lecrc32 (&gpt->primary, &gpt->primary.crc32))
+    return grub_errno;
+
+  if (grub_gpt_header_lecrc32 (&gpt->backup, &gpt->backup.crc32))
+    return grub_errno;
+
+  /* Sanity check.  */
+  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
+
+  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
+
+  gpt->status |= (GRUB_GPT_PRIMARY_HEADER_VALID |
+		  GRUB_GPT_PRIMARY_ENTRIES_VALID |
+		  GRUB_GPT_BACKUP_HEADER_VALID |
+		  GRUB_GPT_BACKUP_ENTRIES_VALID);
+
+  return GRUB_ERR_NONE;
+}
+
 void
 grub_gpt_free (grub_gpt_t gpt)
 {
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 7f41e22dd..62d027e4e 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -141,6 +141,9 @@ grub_gpt_sector_to_addr (grub_gpt_t gpt, grub_uint64_t sector)
 /* Allocates and fills new grub_gpt structure, free with grub_gpt_free.  */
 grub_gpt_t grub_gpt_read (grub_disk_t disk);
 
+/* Sync up primary and backup headers, recompute checksums.  */
+grub_err_t grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt);
+
 void grub_gpt_free (grub_gpt_t gpt);
 
 grub_err_t grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr);
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index 4d70868af..83198bebf 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -24,6 +24,7 @@
 #include <grub/err.h>
 #include <grub/gpt_partition.h>
 #include <grub/msdos_partition.h>
+#include <grub/lib/hexdump.h>
 #include <grub/test.h>
 
 #include <errno.h>
@@ -442,6 +443,52 @@ read_fallback_test (void)
   close_disk (&data);
 }
 
+static void
+repair_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Erase/Repair primary.  */
+  memset (&data.raw->primary_header, 0, sizeof (data.raw->primary_header));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_gpt_repair (data.dev->disk, gpt);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "repair failed: %s", grub_errmsg);
+  if (memcmp (&gpt->primary, &example_primary, sizeof (gpt->primary)))
+    {
+      printf ("Invalid restored primary header:\n");
+      hexdump (16, (char*)&gpt->primary, sizeof (gpt->primary));
+      printf ("Expected primary header:\n");
+      hexdump (16, (char*)&example_primary, sizeof (example_primary));
+      grub_test_assert (0, "repair did not restore primary header");
+    }
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Erase/Repair backup.  */
+  memset (&data.raw->backup_header, 0, sizeof (data.raw->backup_header));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_gpt_repair (data.dev->disk, gpt);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "repair failed: %s", grub_errmsg);
+  if (memcmp (&gpt->backup, &example_backup, sizeof (gpt->backup)))
+    {
+      printf ("Invalid restored backup header:\n");
+      hexdump (16, (char*)&gpt->backup, sizeof (gpt->backup));
+      printf ("Expected backup header:\n");
+      hexdump (16, (char*)&example_backup, sizeof (example_backup));
+      grub_test_assert (0, "repair did not restore backup header");
+    }
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  close_disk (&data);
+}
 void
 grub_unit_test_init (void)
 {
@@ -453,6 +500,7 @@ grub_unit_test_init (void)
   grub_test_register ("gpt_read_valid_test", read_valid_test);
   grub_test_register ("gpt_read_invalid_test", read_invalid_entries_test);
   grub_test_register ("gpt_read_fallback_test", read_fallback_test);
+  grub_test_register ("gpt_repair_test", repair_test);
 }
 
 void
@@ -463,5 +511,6 @@ grub_unit_test_fini (void)
   grub_test_unregister ("gpt_read_valid_test");
   grub_test_unregister ("gpt_read_invalid_test");
   grub_test_unregister ("gpt_read_fallback_test");
+  grub_test_unregister ("gpt_repair_test");
   grub_fini_all ();
 }
From c9041ec4e40315f2734f2b6a38a75ba17cbba0ca Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sun, 19 Oct 2014 14:21:29 -0700
Subject: [PATCH] gpt: add write function and gptrepair command

The first hint of something practical, a command that can restore any of
the GPT structures from the alternate location. New test case must run
under QEMU because the loopback device used by the other unit tests does
not support writing.
---
 Makefile.util.def              |   6 +++
 grub-core/Makefile.core.def    |   5 ++
 grub-core/commands/gptrepair.c | 116 +++++++++++++++++++++++++++++++++++++++++
 grub-core/lib/gpt.c            |  44 ++++++++++++++--
 include/grub/gpt_partition.h   |   8 +++
 tests/gptrepair_test.in        | 102 ++++++++++++++++++++++++++++++++++++
 6 files changed, 277 insertions(+), 4 deletions(-)
 create mode 100644 grub-core/commands/gptrepair.c
 create mode 100644 tests/gptrepair_test.in

diff --git a/Makefile.util.def b/Makefile.util.def
index 48448c28d..8156fca5f 100644
--- a/Makefile.util.def
+++ b/Makefile.util.def
@@ -1159,6 +1159,12 @@ script = {
   common = tests/grub_cmd_tr.in;
 };
 
+script = {
+  testcase;
+  name = gptrepair_test;
+  common = tests/gptrepair_test.in;
+};
+
 script = {
   testcase;
   name = file_filter_test;
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index d3bcdbe2f..23a047632 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -821,6 +821,11 @@ module = {
   common = commands/gptsync.c;
 };
 
+module = {
+  name = gptrepair;
+  common = commands/gptrepair.c;
+};
+
 module = {
   name = gpt;
   common = lib/gpt.c;
diff --git a/grub-core/commands/gptrepair.c b/grub-core/commands/gptrepair.c
new file mode 100644
index 000000000..38392fd8f
--- /dev/null
+++ b/grub-core/commands/gptrepair.c
@@ -0,0 +1,116 @@
+/* gptrepair.c - verify and restore GPT info from alternate location.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2009  Free Software Foundation, Inc.
+ *  Copyright (C) 2014  CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/command.h>
+#include <grub/device.h>
+#include <grub/err.h>
+#include <grub/gpt_partition.h>
+#include <grub/i18n.h>
+#include <grub/misc.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static char *
+trim_dev_name (char *name)
+{
+  grub_size_t len = grub_strlen (name);
+  if (len && name[0] == '(' && name[len - 1] == ')')
+    {
+      name[len - 1] = '\0';
+      name = name + 1;
+    }
+  return name;
+}
+
+static grub_err_t
+grub_cmd_gptrepair (grub_command_t cmd __attribute__ ((unused)),
+		    int argc, char **args)
+{
+  grub_device_t dev = NULL;
+  grub_gpt_t gpt = NULL;
+  char *dev_name;
+  grub_uint32_t primary_crc, backup_crc;
+  enum grub_gpt_status old_status;
+
+  if (argc != 1 || !grub_strlen(args[0]))
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, "device name required");
+
+  dev_name = trim_dev_name (args[0]);
+  dev = grub_device_open (dev_name);
+  if (!dev)
+    goto done;
+
+  if (!dev->disk)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, "not a disk");
+      goto done;
+    }
+
+  gpt = grub_gpt_read (dev->disk);
+  if (!gpt)
+    goto done;
+
+  primary_crc = gpt->primary.crc32;
+  backup_crc = gpt->backup.crc32;
+  old_status = gpt->status;
+
+  if (grub_gpt_repair (dev->disk, gpt))
+    goto done;
+
+  if (primary_crc == gpt->primary.crc32 &&
+      backup_crc == gpt->backup.crc32 &&
+      old_status && gpt->status)
+    {
+      grub_printf_ (N_("GPT already valid, %s unmodified.\n"), dev_name);
+      goto done;
+    }
+
+  if (grub_gpt_write (dev->disk, gpt))
+    goto done;
+
+  if (!(old_status & GRUB_GPT_PRIMARY_VALID))
+    grub_printf_ (N_("Primary GPT for %s repaired.\n"), dev_name);
+
+  if (!(old_status & GRUB_GPT_BACKUP_VALID))
+    grub_printf_ (N_("Backup GPT for %s repaired.\n"), dev_name);
+
+done:
+  if (gpt)
+    grub_gpt_free (gpt);
+
+  if (dev)
+    grub_device_close (dev);
+
+  return grub_errno;
+}
+
+static grub_command_t cmd;
+
+GRUB_MOD_INIT(gptrepair)
+{
+  cmd = grub_register_command ("gptrepair", grub_cmd_gptrepair,
+			       N_("DEVICE"),
+			       N_("Verify and repair GPT on drive DEVICE."));
+}
+
+GRUB_MOD_FINI(gptrepair)
+{
+  grub_unregister_command (cmd);
+}
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 2d61df488..67ffdf703 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -357,10 +357,46 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
     return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
 
-  gpt->status |= (GRUB_GPT_PRIMARY_HEADER_VALID |
-		  GRUB_GPT_PRIMARY_ENTRIES_VALID |
-		  GRUB_GPT_BACKUP_HEADER_VALID |
-		  GRUB_GPT_BACKUP_ENTRIES_VALID);
+  gpt->status |= GRUB_GPT_BOTH_VALID;
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_write_table (grub_disk_t disk, grub_gpt_t gpt,
+		      struct grub_gpt_header *header)
+{
+  grub_disk_addr_t addr;
+
+  if (grub_le_to_cpu32 (header->headersize) != sizeof (*header))
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "Header size is %u, must be %u",
+		       grub_le_to_cpu32 (header->headersize),
+		       sizeof (*header));
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->header_lba));
+  if (grub_disk_write (disk, addr, 0, sizeof (*header), header))
+    return grub_errno;
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->partitions));
+  if (grub_disk_write (disk, addr, 0, gpt->entries_size, gpt->entries))
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt)
+{
+  /* TODO: update/repair protective MBRs too.  */
+
+  if (!(gpt->status & GRUB_GPT_BOTH_VALID))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "Invalid GPT data");
+
+  if (grub_gpt_write_table (disk, gpt, &gpt->primary))
+    return grub_errno;
+
+  if (grub_gpt_write_table (disk, gpt, &gpt->backup))
+    return grub_errno;
 
   return GRUB_ERR_NONE;
 }
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 62d027e4e..3cac6df32 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -103,6 +103,11 @@ typedef enum grub_gpt_status
   } grub_gpt_status_t;
 
 #define GRUB_GPT_MBR_VALID (GRUB_GPT_PROTECTIVE_MBR|GRUB_GPT_HYBRID_MBR)
+#define GRUB_GPT_PRIMARY_VALID \
+  (GRUB_GPT_PRIMARY_HEADER_VALID|GRUB_GPT_PRIMARY_ENTRIES_VALID)
+#define GRUB_GPT_BACKUP_VALID \
+  (GRUB_GPT_BACKUP_HEADER_VALID|GRUB_GPT_BACKUP_ENTRIES_VALID)
+#define GRUB_GPT_BOTH_VALID (GRUB_GPT_PRIMARY_VALID|GRUB_GPT_BACKUP_VALID)
 
 /* UEFI requires the entries table to be at least 16384 bytes for a
  * total of 128 entries given the standard 128 byte entry size.  */
@@ -144,6 +149,9 @@ grub_gpt_t grub_gpt_read (grub_disk_t disk);
 /* Sync up primary and backup headers, recompute checksums.  */
 grub_err_t grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt);
 
+/* Write headers and entry tables back to disk.  */
+grub_err_t grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt);
+
 void grub_gpt_free (grub_gpt_t gpt);
 
 grub_err_t grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr);
diff --git a/tests/gptrepair_test.in b/tests/gptrepair_test.in
new file mode 100644
index 000000000..80b2de633
--- /dev/null
+++ b/tests/gptrepair_test.in
@@ -0,0 +1,102 @@
+#! /bin/sh
+set -e
+
+# Copyright (C) 2010  Free Software Foundation, Inc.
+# Copyright (C) 2014  CoreOS, Inc.
+#
+# GRUB is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# GRUB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+
+parted=parted
+grubshell=@builddir@/grub-shell
+
+. "@builddir@/grub-core/modinfo.sh"
+
+case "${grub_modinfo_target_cpu}-${grub_modinfo_platform}" in
+    mips-qemu_mips | mipsel-qemu_mips | i386-qemu | i386-multiboot | i386-coreboot | mipsel-loongson)
+	disk=ata0
+	;;
+    powerpc-ieee1275)
+	disk=ieee1275//pci@80000000/mac-io@4/ata-3@20000/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    sparc64-ieee1275)
+	disk=ieee1275//pci@1fe\,0/pci-ata@5/ide0@500/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    i386-ieee1275)
+	disk=ieee1275/d
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    mips-arc)
+	# FIXME: ARC firmware has bugs which prevent it from accessing hard disk w/o dvh disklabel.
+	exit 0 ;;
+    mipsel-arc)
+	disk=arc/scsi0/disk0/rdisk0
+	;;
+    *)
+	disk=hd0
+	;;
+esac
+img1="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
+img2="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
+trap "rm -f '${img1}' '${ing2}'" EXIT
+
+create_disk_image () {
+    size=$1
+    rm -f "${img1}"
+    dd if=/dev/zero of="${img1}" bs=512 count=1 seek=$((size - 1)) status=none
+    ${parted} -a none -s "${img1}" mklabel gpt
+    cp "${img1}" "${img2}"
+}
+
+wipe_disk_area () {
+    sector=$1
+    size=$2
+    dd if=/dev/zero of="${img2}" bs=512 count=${size} seek=${sector} conv=notrunc status=none
+}
+
+do_repair () {
+    output="`echo "gptrepair ($disk)" | "${grubshell}" --disk="${img2}"`"
+    if echo "${output}" | grep ^error; then
+        return 1
+    fi
+    if echo "${output}" | grep -v GPT; then
+        echo "Unexpected output ${output}"
+        return 1
+    fi
+    echo "${output}"
+}
+
+echo "Nothing to repair:"
+create_disk_image 100
+do_repair
+cmp "${img1}" "${img2}"
+echo
+
+echo "Repair primary (MBR left intact)"
+create_disk_image 100
+wipe_disk_area 1 1
+do_repair
+cmp "${img1}" "${img2}"
+echo
+
+echo "Repair backup"
+create_disk_image 100
+wipe_disk_area 99 1
+do_repair
+cmp "${img1}" "${img2}"
+echo
From 24341bb2904a4f2b40d69dbd633789cf49e9616b Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sun, 19 Oct 2014 20:44:34 -0700
Subject: [PATCH] tests: fix path to words file on Gentoo/CoreOS

By default there isn't a linux.words file, but there is words.
---
 tests/util/grub-fs-tester.in | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/tests/util/grub-fs-tester.in b/tests/util/grub-fs-tester.in
index 2337771a1..d768d66d1 100644
--- a/tests/util/grub-fs-tester.in
+++ b/tests/util/grub-fs-tester.in
@@ -241,8 +241,10 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    CFILESN=1
 	    if test -f /usr/share/dict/american-english; then
 		CFILESSRC[0]="/usr/share/dict/american-english"
-	    else
+	    elif test -f /usr/share/dict/linux.words; then
 		CFILESSRC[0]="/usr/share/dict/linux.words"
+	    else
+		CFILESSRC[0]="/usr/share/dict/words"
 	    fi
 	    case x"$fs" in
 		    # FS LIMITATION: 8.3 names
From 059ae5370a9d5f7fe19c928bf5000751ece28ccd Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 30 Oct 2014 20:55:21 -0700
Subject: [PATCH] gpt: add a new generic GUID type

In order to do anything with partition GUIDs they need to be stored in a
proper structure like the partition type GUIDs. Additionally add an
initializer macro to simplify defining both GUID types.
---
 include/grub/gpt_partition.h | 36 +++++++++++++++++++-----------------
 tests/gpt_unit_test.c        | 12 ++++++------
 2 files changed, 25 insertions(+), 23 deletions(-)

diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 3cac6df32..df076ca64 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -23,33 +23,35 @@
 #include <grub/partition.h>
 #include <grub/msdos_partition.h>
 
-struct grub_gpt_part_type
+struct grub_gpt_guid
 {
   grub_uint32_t data1;
   grub_uint16_t data2;
   grub_uint16_t data3;
   grub_uint8_t data4[8];
 } __attribute__ ((aligned(8)));
-typedef struct grub_gpt_part_type grub_gpt_part_type_t;
+typedef struct grub_gpt_guid grub_gpt_guid_t;
+typedef struct grub_gpt_guid grub_gpt_part_type_t;
+
+#define GRUB_GPT_GUID_INIT(a, b, c, d1, d2, d3, d4, d5, d6, d7, d8)  \
+  {					\
+    grub_cpu_to_le32_compile_time (a),	\
+    grub_cpu_to_le16_compile_time (b),	\
+    grub_cpu_to_le16_compile_time (c),	\
+    { d1, d2, d3, d4, d5, d6, d7, d8 }	\
+  }
 
 #define GRUB_GPT_PARTITION_TYPE_EMPTY \
-  { 0x0, 0x0, 0x0, \
-    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } \
-  }
+  GRUB_GPT_GUID_INIT (0x0, 0x0, 0x0,  \
+      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
 
 #define GRUB_GPT_PARTITION_TYPE_BIOS_BOOT \
-  { grub_cpu_to_le32_compile_time (0x21686148), \
-      grub_cpu_to_le16_compile_time (0x6449), \
-      grub_cpu_to_le16_compile_time (0x6e6f),	       \
-    { 0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49 } \
-  }
+  GRUB_GPT_GUID_INIT (0x21686148, 0x6449, 0x6e6f, \
+      0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49)
 
 #define GRUB_GPT_PARTITION_TYPE_LDM \
-  { grub_cpu_to_le32_compile_time (0x5808C8AAU),\
-      grub_cpu_to_le16_compile_time (0x7E8F), \
-      grub_cpu_to_le16_compile_time (0x42E0),	       \
-	{ 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3 }	\
-  }
+  GRUB_GPT_GUID_INIT (0x5808c8aa, 0x7e8f, 0x42e0, \
+      0x85, 0xd2, 0xe1, 0xe9, 0x04, 0x34, 0xcf, 0xb3)
 
 #define GRUB_GPT_HEADER_MAGIC \
   { 0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54 }
@@ -68,7 +70,7 @@ struct grub_gpt_header
   grub_uint64_t alternate_lba;
   grub_uint64_t start;
   grub_uint64_t end;
-  grub_uint8_t guid[16];
+  grub_gpt_guid_t guid;
   grub_uint64_t partitions;
   grub_uint32_t maxpart;
   grub_uint32_t partentry_size;
@@ -78,7 +80,7 @@ struct grub_gpt_header
 struct grub_gpt_partentry
 {
   grub_gpt_part_type_t type;
-  grub_uint8_t guid[16];
+  grub_gpt_guid_t guid;
   grub_uint64_t start;
   grub_uint64_t end;
   grub_uint64_t attrib;
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index 83198bebf..86e4364a5 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -99,8 +99,8 @@ static const struct grub_gpt_header example_primary = {
   .alternate_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
   .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
   .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
-  .guid = {0xad, 0x31, 0xc1, 0x69, 0xd6, 0x67, 0xc6, 0x46,
-	   0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac},
+  .guid = GRUB_GPT_GUID_INIT(0x69c131ad, 0x67d6, 0x46c6,
+			     0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac),
   .partitions = grub_cpu_to_le64_compile_time (PRIMARY_TABLE_SECTOR),
   .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
   .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
@@ -117,8 +117,8 @@ static const struct grub_gpt_header example_backup = {
   .alternate_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
   .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
   .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
-  .guid = {0xad, 0x31, 0xc1, 0x69, 0xd6, 0x67, 0xc6, 0x46,
-	   0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac},
+  .guid = GRUB_GPT_GUID_INIT(0x69c131ad, 0x67d6, 0x46c6,
+			     0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac),
   .partitions = grub_cpu_to_le64_compile_time (BACKUP_TABLE_SECTOR),
   .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
   .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
@@ -326,13 +326,13 @@ header_test (void)
   grub_errno = GRUB_ERR_NONE;
 
   /* Twiddle the GUID to invalidate the CRC. */
-  primary.guid[0] = 0;
+  primary.guid.data1 = 0;
   grub_gpt_header_check (&primary, GRUB_DISK_SECTOR_BITS);
   grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
 		    "unexpected error: %s", grub_errmsg);
   grub_errno = GRUB_ERR_NONE;
 
-  backup.guid[0] = 0;
+  backup.guid.data1 = 0;
   grub_gpt_header_check (&backup, GRUB_DISK_SECTOR_BITS);
   grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
 		    "unexpected error: %s", grub_errmsg);
From 6cf94a34ca4f605aa353d2717561d608bc13472d Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Mon, 3 Nov 2014 17:14:37 -0800
Subject: [PATCH] gpt: new gptprio.next command for selecting priority based
 partitions

Basic usage would look something like this:

    gptprio.next -d usr_dev -u usr_uuid
    linuxefi ($usr_dev)/boot/vmlinuz mount.usr=PARTUUID=$usr_uuid

After booting the system should set the 'successful' bit on the
partition that was used.
---
 Makefile.util.def            |   6 ++
 grub-core/Makefile.core.def  |   5 +
 grub-core/commands/gptprio.c | 238 +++++++++++++++++++++++++++++++++++++++++++
 include/grub/gpt_partition.h |  49 +++++++++
 tests/gptprio_test.in        | 150 +++++++++++++++++++++++++++
 5 files changed, 448 insertions(+)
 create mode 100644 grub-core/commands/gptprio.c
 create mode 100644 tests/gptprio_test.in

diff --git a/Makefile.util.def b/Makefile.util.def
index 8156fca5f..9249f77be 100644
--- a/Makefile.util.def
+++ b/Makefile.util.def
@@ -1165,6 +1165,12 @@ script = {
   common = tests/gptrepair_test.in;
 };
 
+script = {
+  testcase;
+  name = gptprio_test;
+  common = tests/gptprio_test.in;
+};
+
 script = {
   testcase;
   name = file_filter_test;
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 23a047632..4620138cb 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -826,6 +826,11 @@ module = {
   common = commands/gptrepair.c;
 };
 
+module = {
+  name = gptprio;
+  common = commands/gptprio.c;
+};
+
 module = {
   name = gpt;
   common = lib/gpt.c;
diff --git a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
new file mode 100644
index 000000000..29bd11d68
--- /dev/null
+++ b/grub-core/commands/gptprio.c
@@ -0,0 +1,238 @@
+/* gptprio.c - manage priority based partition selection.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2009  Free Software Foundation, Inc.
+ *  Copyright (C) 2014  CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/device.h>
+#include <grub/env.h>
+#include <grub/err.h>
+#include <grub/extcmd.h>
+#include <grub/gpt_partition.h>
+#include <grub/i18n.h>
+#include <grub/misc.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static const struct grub_arg_option options_next[] = {
+  {"set-device", 'd', 0,
+   N_("Set a variable to the name of selected partition."),
+   N_("VARNAME"), ARG_TYPE_STRING},
+  {"set-uuid", 'u', 0,
+   N_("Set a variable to the GPT UUID of selected partition."),
+   N_("VARNAME"), ARG_TYPE_STRING},
+  {0, 0, 0, 0, 0, 0}
+};
+
+enum options_next
+{
+  NEXT_SET_DEVICE,
+  NEXT_SET_UUID,
+};
+
+static unsigned int
+grub_gptprio_priority (struct grub_gpt_partentry *entry)
+{
+  return (unsigned int) grub_gpt_entry_attribute
+    (entry, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_PRIORITY, 4);
+}
+
+static unsigned int
+grub_gptprio_tries_left (struct grub_gpt_partentry *entry)
+{
+  return (unsigned int) grub_gpt_entry_attribute
+    (entry, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_TRIES_LEFT, 4);
+}
+
+static void
+grub_gptprio_set_tries_left (struct grub_gpt_partentry *entry,
+			     unsigned int tries_left)
+{
+  grub_gpt_entry_set_attribute
+    (entry, tries_left, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_TRIES_LEFT, 4);
+}
+
+static unsigned int
+grub_gptprio_successful (struct grub_gpt_partentry *entry)
+{
+  return (unsigned int) grub_gpt_entry_attribute
+    (entry, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_SUCCESSFUL, 1);
+}
+
+static grub_err_t
+grub_find_next (const char *disk_name,
+		const grub_gpt_part_type_t *part_type,
+		char **part_name, char **part_guid)
+{
+  struct grub_gpt_partentry *part_found = NULL;
+  grub_device_t dev = NULL;
+  grub_gpt_t gpt = NULL;
+  grub_uint32_t i, part_index;
+
+  dev = grub_device_open (disk_name);
+  if (!dev)
+    goto done;
+
+  gpt = grub_gpt_read (dev->disk);
+  if (!gpt)
+    goto done;
+
+  if (!(gpt->status & GRUB_GPT_BOTH_VALID))
+    if (grub_gpt_repair (dev->disk, gpt))
+      goto done;
+
+  for (i = 0; i < grub_le_to_cpu32 (gpt->primary.maxpart); i++)
+    {
+      struct grub_gpt_partentry *part = &gpt->entries[i];
+
+      if (grub_memcmp (part_type, &part->type, sizeof (*part_type)) == 0)
+	{
+	  unsigned int priority, tries_left, successful, old_priority = 0;
+
+	  priority = grub_gptprio_priority (part);
+	  tries_left = grub_gptprio_tries_left (part);
+	  successful = grub_gptprio_successful (part);
+
+	  if (part_found)
+	    old_priority = grub_gptprio_priority (part_found);
+
+	  if ((tries_left || successful) && priority > old_priority)
+	    {
+	      part_index = i;
+	      part_found = part;
+	    }
+	}
+    }
+
+  if (!part_found)
+    {
+      grub_error (GRUB_ERR_UNKNOWN_DEVICE, N_("no such partition"));
+      goto done;
+    }
+
+  if (grub_gptprio_tries_left (part_found))
+    {
+      unsigned int tries_left = grub_gptprio_tries_left (part_found);
+
+      grub_gptprio_set_tries_left (part_found, tries_left - 1);
+
+      if (grub_gpt_update_checksums (gpt))
+	goto done;
+
+      if (grub_gpt_write (dev->disk, gpt))
+	goto done;
+    }
+
+  *part_name = grub_xasprintf ("%s,gpt%u", disk_name, part_index + 1);
+  if (!*part_name)
+    goto done;
+
+  *part_guid =
+    grub_xasprintf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+		    grub_le_to_cpu32 (part_found->guid.data1),
+		    grub_le_to_cpu16 (part_found->guid.data2),
+		    grub_le_to_cpu16 (part_found->guid.data3),
+		    part_found->guid.data4[0],
+		    part_found->guid.data4[1],
+		    part_found->guid.data4[2],
+		    part_found->guid.data4[3],
+		    part_found->guid.data4[4],
+		    part_found->guid.data4[5],
+		    part_found->guid.data4[6],
+		    part_found->guid.data4[7]);
+  if (!*part_name)
+    goto done;
+
+  grub_errno = GRUB_ERR_NONE;
+
+done:
+  grub_gpt_free (gpt);
+
+  if (dev)
+    grub_device_close (dev);
+
+  return grub_errno;
+}
+
+
+
+static grub_err_t
+grub_cmd_next (grub_extcmd_context_t ctxt, int argc, char **args)
+{
+  struct grub_arg_list *state = ctxt->state;
+  char *p, *root = NULL, *part_name = NULL, *part_guid = NULL;
+
+  /* TODO: Add a uuid parser and a command line flag for providing type.  */
+  grub_gpt_part_type_t part_type = GRUB_GPT_PARTITION_TYPE_USR_X86_64;
+
+  if (!state[NEXT_SET_DEVICE].set || !state[NEXT_SET_UUID].set)
+    {
+      grub_error (GRUB_ERR_INVALID_COMMAND, N_("-d and -u are required"));
+      goto done;
+    }
+
+  if (argc == 0)
+    root = grub_strdup (grub_env_get ("root"));
+  else if (argc == 1)
+    root = grub_strdup (args[0]);
+  else
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, N_("unexpected arguments"));
+      goto done;
+    }
+
+  if (!root)
+    goto done;
+
+  /* To make using $root practical strip off the partition name.  */
+  p = grub_strchr (root, ',');
+  if (p)
+    *p = '\0';
+
+  if (grub_find_next (root, &part_type, &part_name, &part_guid))
+    goto done;
+
+  if (grub_env_set (state[NEXT_SET_DEVICE].arg, part_name))
+    goto done;
+
+  if (grub_env_set (state[NEXT_SET_UUID].arg, part_guid))
+    goto done;
+
+  grub_errno = GRUB_ERR_NONE;
+
+done:
+  grub_free (root);
+  grub_free (part_name);
+  grub_free (part_guid);
+
+  return grub_errno;
+}
+
+static grub_extcmd_t cmd_next;
+
+GRUB_MOD_INIT(gptprio)
+{
+  cmd_next = grub_register_extcmd ("gptprio.next", grub_cmd_next, 0,
+				   N_("-d VARNAME -u VARNAME [DEVICE]"),
+				   N_("Select next partition to boot."),
+				   options_next);
+}
+
+GRUB_MOD_FINI(gptprio)
+{
+  grub_unregister_extcmd (cmd_next);
+}
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index df076ca64..e41c66539 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -53,6 +53,10 @@ typedef struct grub_gpt_guid grub_gpt_part_type_t;
   GRUB_GPT_GUID_INIT (0x5808c8aa, 0x7e8f, 0x42e0, \
       0x85, 0xd2, 0xe1, 0xe9, 0x04, 0x34, 0xcf, 0xb3)
 
+#define GRUB_GPT_PARTITION_TYPE_USR_X86_64 \
+  GRUB_GPT_GUID_INIT (0x5dfbf5f4, 0x2848, 0x4bac, \
+      0xaa, 0x5e, 0x0d, 0x9a, 0x20, 0xb7, 0x45, 0xa6)
+
 #define GRUB_GPT_HEADER_MAGIC \
   { 0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54 }
 
@@ -87,6 +91,51 @@ struct grub_gpt_partentry
   char name[72];
 } GRUB_PACKED;
 
+enum grub_gpt_part_attr_offset
+{
+  /* Standard partition attribute bits defined by UEFI.  */
+  GRUB_GPT_PART_ATTR_OFFSET_REQUIRED			= 0,
+  GRUB_GPT_PART_ATTR_OFFSET_NO_BLOCK_IO_PROTOCOL	= 1,
+  GRUB_GPT_PART_ATTR_OFFSET_LEGACY_BIOS_BOOTABLE	= 2,
+
+  /* De facto standard attribute bits defined by Microsoft and reused by
+   * http://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec */
+  GRUB_GPT_PART_ATTR_OFFSET_READ_ONLY			= 60,
+  GRUB_GPT_PART_ATTR_OFFSET_NO_AUTO			= 63,
+
+  /* Partition attributes for priority based selection,
+   * Currently only valid for PARTITION_TYPE_USR_X86_64.
+   * TRIES_LEFT and PRIORITY are 4 bit wide fields.  */
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_PRIORITY		= 48,
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_TRIES_LEFT		= 52,
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_SUCCESSFUL		= 56,
+};
+
+/* Helpers for reading/writing partition attributes.  */
+static inline grub_uint64_t
+grub_gpt_entry_attribute (struct grub_gpt_partentry *entry,
+			  enum grub_gpt_part_attr_offset offset,
+			  unsigned int bits)
+{
+  grub_uint64_t attrib = grub_le_to_cpu64 (entry->attrib);
+
+  return (attrib >> offset) & ((1ULL << bits) - 1);
+}
+
+static inline void
+grub_gpt_entry_set_attribute (struct grub_gpt_partentry *entry,
+			      grub_uint64_t value,
+			      enum grub_gpt_part_attr_offset offset,
+			      unsigned int bits)
+{
+  grub_uint64_t attrib, mask;
+
+  mask = (((1ULL << bits) - 1) << offset);
+  attrib = grub_le_to_cpu64 (entry->attrib) & ~mask;
+  attrib |= ((value << offset) & mask);
+  entry->attrib = grub_cpu_to_le64 (attrib);
+}
+
 /* Basic GPT partmap module.  */
 grub_err_t
 grub_gpt_partition_map_iterate (grub_disk_t disk,
diff --git a/tests/gptprio_test.in b/tests/gptprio_test.in
new file mode 100644
index 000000000..f4aea0dc9
--- /dev/null
+++ b/tests/gptprio_test.in
@@ -0,0 +1,150 @@
+#! /bin/bash
+set -e
+
+# Copyright (C) 2010  Free Software Foundation, Inc.
+# Copyright (C) 2014  CoreOS, Inc.
+#
+# GRUB is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# GRUB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+
+sgdisk=sgdisk
+grubshell=@builddir@/grub-shell
+
+if ! which "${sgdisk}" >/dev/null 2>&1; then
+   echo "sgdisk not installed; cannot test gptprio."
+   exit 77
+fi
+
+. "@builddir@/grub-core/modinfo.sh"
+
+case "${grub_modinfo_target_cpu}-${grub_modinfo_platform}" in
+    mips-qemu_mips | mipsel-qemu_mips | i386-qemu | i386-multiboot | i386-coreboot | mipsel-loongson)
+	disk=ata0
+	;;
+    powerpc-ieee1275)
+	disk=ieee1275//pci@80000000/mac-io@4/ata-3@20000/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    sparc64-ieee1275)
+	disk=ieee1275//pci@1fe\,0/pci-ata@5/ide0@500/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    i386-ieee1275)
+	disk=ieee1275/d
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    mips-arc)
+	# FIXME: ARC firmware has bugs which prevent it from accessing hard disk w/o dvh disklabel.
+	exit 0 ;;
+    mipsel-arc)
+	disk=arc/scsi0/disk0/rdisk0
+	;;
+    *)
+	disk=hd0
+	;;
+esac
+img1="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
+trap "rm -f '${img1}'" EXIT
+
+prio_type="5dfbf5f4-2848-4bac-aa5e-0d9a20b745a6"
+declare -a prio_uuid
+prio_uuid[2]="9b003904-d006-4ab3-97f1-73f547b7af1a"
+prio_uuid[3]="1aa5a658-5b02-414d-9b71-f7e6c151f0cd"
+prio_uuid[4]="8aa0240d-98af-42b0-b32a-ccbe0572d62b"
+
+create_disk_image () {
+    rm -f "${img1}"
+    dd if=/dev/zero of="${img1}" bs=512 count=1 seek=100 status=none
+    ${sgdisk} \
+        -n 1:0:+1 -c 1:ESP -t 1:ef00 \
+        -n 2:0:+1 -c 2:A -t 2:"${prio_type}" -u 2:"${prio_uuid[2]}" \
+        -n 3:0:+1 -c 3:B -t 3:"${prio_type}" -u 3:"${prio_uuid[3]}" \
+        -n 4:0:+1 -c 4:C -t 4:"${prio_type}" -u 4:"${prio_uuid[4]}" \
+        "${img1}" >/dev/null
+}
+
+
+fmt_prio () {
+    priority=$(( ( $1 & 15 ) << 48 ))
+    tries=$(( ( $2 & 15 ) << 52 ))
+    success=$(( ( $3 & 1 ) << 56 ))
+    printf %016x $(( priority | tries | success ))
+}
+
+set_prio () {
+    part="$1"
+    attr=$(fmt_prio $2 $3 $4)
+    ${sgdisk} -A "${part}:=:${attr}" "${img1}" >/dev/null
+}
+
+check_prio () {
+    part="$1"
+    expect=$(fmt_prio $2 $3 $4)
+    result=$(LANG=C ${sgdisk} -i "${part}" "${img1}" \
+            | awk '/^Attribute flags: / {print $3}')
+    if [[ "${expect}" != "${result}" ]]; then
+        echo "Partition ${part} has attributes ${result}, not ${expect}" >&2
+        exit 1
+    fi
+}
+
+run_next() {
+    "${grubshell}" --disk="${img1}" --modules=gptprio <<EOF
+gptprio.next -d next_dev -u next_uuid "${disk}"
+echo next_dev=\$next_dev
+echo next_uuid=\$next_uuid
+EOF
+}
+
+check_next () {
+    part="$1"
+    output=$(run_next)
+    if grep ^error <<<"${output}"; then
+        exit 1
+    fi
+    if ! grep -q "^next_dev=${disk},gpt${part}$" <<<"${output}"; then
+        echo "Unexpected next_dev: (expected ${disk},gpt${part})"
+        echo "${output}"
+        exit 1
+    fi
+    if ! grep -q "^next_uuid=${prio_uuid[$part]}$" <<<"${output}"; then
+        echo "Unexpected next_uuid: (expected ${prio_uuid[$part]})"
+        echo "${output}"
+        exit 1
+    fi
+    check_prio "$@"
+}
+
+# Basic sanity check
+create_disk_image 100
+set_prio 2 3 2 1
+check_prio 2 3 2 1
+
+# Try two partitions before falling before falling back to a third
+create_disk_image 100
+set_prio 2 3 3 0
+set_prio 3 2 2 0
+set_prio 4 1 0 1
+check_next 2 3 2 0
+check_next 2 3 1 0
+check_next 2 3 0 0
+check_next 3 2 1 0
+check_next 3 2 0 0
+check_next 4 1 0 1
+check_next 4 1 0 1
+check_next 4 1 0 1
+check_prio 2 3 0 0
+check_prio 3 2 0 0
From 72c4965a868b1d44d9ecb447829597ad4cace93e Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sat, 15 Nov 2014 13:27:13 -0800
Subject: [PATCH] gpt: split out checksum recomputation

For basic data modifications the full repair function is overkill.
---
 grub-core/lib/gpt.c          | 30 ++++++++++++++++++++----------
 include/grub/gpt_partition.h |  3 +++
 2 files changed, 23 insertions(+), 10 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 67ffdf703..198234071 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -293,7 +293,6 @@ grub_err_t
 grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 {
   grub_uint64_t backup_header, backup_entries;
-  grub_uint32_t crc;
 
   if (disk->log_sector_size != gpt->log_sector_size)
     return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
@@ -331,13 +330,32 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   gpt->backup.alternate_lba = gpt->primary.header_lba;
   gpt->backup.partitions = grub_cpu_to_le64 (backup_entries);
 
+  /* Recompute checksums.  */
+  if (grub_gpt_update_checksums (gpt))
+    return grub_errno;
+
+  /* Sanity check.  */
+  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
+
+  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
+
+  gpt->status |= GRUB_GPT_BOTH_VALID;
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_update_checksums (grub_gpt_t gpt)
+{
+  grub_uint32_t crc;
+
   /* Writing headers larger than our header structure are unsupported.  */
   gpt->primary.headersize =
     grub_cpu_to_le32_compile_time (sizeof (gpt->primary));
   gpt->backup.headersize =
     grub_cpu_to_le32_compile_time (sizeof (gpt->backup));
 
-  /* Recompute checksums.  */
   if (grub_gpt_lecrc32 (gpt->entries, gpt->entries_size, &crc))
     return grub_errno;
 
@@ -350,14 +368,6 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   if (grub_gpt_header_lecrc32 (&gpt->backup, &gpt->backup.crc32))
     return grub_errno;
 
-  /* Sanity check.  */
-  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
-    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
-
-  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
-    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
-
-  gpt->status |= GRUB_GPT_BOTH_VALID;
   return GRUB_ERR_NONE;
 }
 
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index e41c66539..50592d6d0 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -200,6 +200,9 @@ grub_gpt_t grub_gpt_read (grub_disk_t disk);
 /* Sync up primary and backup headers, recompute checksums.  */
 grub_err_t grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt);
 
+/* Recompute checksums, must be called after modifying GPT data.  */
+grub_err_t grub_gpt_update_checksums (grub_gpt_t gpt);
+
 /* Write headers and entry tables back to disk.  */
 grub_err_t grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt);
 
From 548fe74144c4745f25c6a488f99cf3a7c04aa20b Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 27 Nov 2014 12:55:53 -0800
Subject: [PATCH] gpt: move gpt guid printing function to common library

---
 grub-core/commands/gptprio.c | 16 ++--------------
 grub-core/lib/gpt.c          | 13 +++++++++++++
 include/grub/gpt_partition.h |  4 ++++
 3 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
index 29bd11d68..ce5840b4e 100644
--- a/grub-core/commands/gptprio.c
+++ b/grub-core/commands/gptprio.c
@@ -141,20 +141,8 @@ grub_find_next (const char *disk_name,
   if (!*part_name)
     goto done;
 
-  *part_guid =
-    grub_xasprintf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-		    grub_le_to_cpu32 (part_found->guid.data1),
-		    grub_le_to_cpu16 (part_found->guid.data2),
-		    grub_le_to_cpu16 (part_found->guid.data3),
-		    part_found->guid.data4[0],
-		    part_found->guid.data4[1],
-		    part_found->guid.data4[2],
-		    part_found->guid.data4[3],
-		    part_found->guid.data4[4],
-		    part_found->guid.data4[5],
-		    part_found->guid.data4[6],
-		    part_found->guid.data4[7]);
-  if (!*part_name)
+  *part_guid = grub_gpt_guid_to_str (&part_found->guid);
+  if (!*part_guid)
     goto done;
 
   grub_errno = GRUB_ERR_NONE;
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 198234071..9a1835b84 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -31,6 +31,19 @@ GRUB_MOD_LICENSE ("GPLv3+");
 static grub_uint8_t grub_gpt_magic[] = GRUB_GPT_HEADER_MAGIC;
 
 
+char *
+grub_gpt_guid_to_str (grub_gpt_guid_t *guid)
+{
+  return grub_xasprintf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+			 grub_le_to_cpu32 (guid->data1),
+			 grub_le_to_cpu16 (guid->data2),
+			 grub_le_to_cpu16 (guid->data3),
+			 guid->data4[0], guid->data4[1],
+			 guid->data4[2], guid->data4[3],
+			 guid->data4[4], guid->data4[5],
+			 guid->data4[6], guid->data4[7]);
+}
+
 static grub_uint64_t
 grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
 {
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 50592d6d0..166fd4b55 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -33,6 +33,10 @@ struct grub_gpt_guid
 typedef struct grub_gpt_guid grub_gpt_guid_t;
 typedef struct grub_gpt_guid grub_gpt_part_type_t;
 
+/* Format the raw little-endian GUID as a newly allocated string.  */
+char * grub_gpt_guid_to_str (grub_gpt_guid_t *guid);
+
+
 #define GRUB_GPT_GUID_INIT(a, b, c, d1, d2, d3, d4, d5, d6, d7, d8)  \
   {					\
     grub_cpu_to_le32_compile_time (a),	\
From ef9950304568defc9cc6a674cbad58a3d7947200 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 27 Nov 2014 14:54:27 -0800
Subject: [PATCH] gpt: switch partition names to a 16 bit type

In UEFI/GPT strings are UTF-16 so use a uint16 to make dealing with the
string practical.
---
 include/grub/gpt_partition.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 166fd4b55..1142317e3 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -92,7 +92,7 @@ struct grub_gpt_partentry
   grub_uint64_t start;
   grub_uint64_t end;
   grub_uint64_t attrib;
-  char name[72];
+  grub_uint16_t name[36];
 } GRUB_PACKED;
 
 enum grub_gpt_part_attr_offset
From 65c930d19113f45719a2f2696a7dac5447ec90ed Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 27 Nov 2014 15:49:57 -0800
Subject: [PATCH] tests: add some partitions to the gpt unit test data

---
 tests/gpt_unit_test.c | 65 +++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 55 insertions(+), 10 deletions(-)

diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index 86e4364a5..5692a5a52 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -89,12 +89,12 @@ struct test_data
 };
 
 
-/* Sample primary GPT header for an empty 1MB disk.  */
+/* Sample primary GPT header for a 1MB disk.  */
 static const struct grub_gpt_header example_primary = {
   .magic = GRUB_GPT_HEADER_MAGIC,
   .version = GRUB_GPT_HEADER_VERSION,
   .headersize = sizeof (struct grub_gpt_header),
-  .crc32 = grub_cpu_to_le32_compile_time (0x7cd8642c),
+  .crc32 = grub_cpu_to_le32_compile_time (0xb985abe0),
   .header_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
   .alternate_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
   .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
@@ -104,7 +104,52 @@ static const struct grub_gpt_header example_primary = {
   .partitions = grub_cpu_to_le64_compile_time (PRIMARY_TABLE_SECTOR),
   .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
   .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
-  .partentry_crc32 = grub_cpu_to_le32_compile_time (0xab54d286),
+  .partentry_crc32 = grub_cpu_to_le32_compile_time (0x074e052c),
+};
+
+static const struct grub_gpt_partentry example_entries[TABLE_ENTRIES] = {
+  {
+    .type = GRUB_GPT_PARTITION_TYPE_EFI_SYSTEM,
+    .guid = GRUB_GPT_GUID_INIT (0xa0f1792e, 0xb4ce, 0x4136, 0xbc, 0xf2,
+				0x1a, 0xfc, 0x13, 0x3c, 0x28, 0x28),
+    .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+    .end = grub_cpu_to_le64_compile_time (0x3f),
+    .attrib = 0x0,
+    .name = {
+      grub_cpu_to_le16_compile_time ('E'),
+      grub_cpu_to_le16_compile_time ('F'),
+      grub_cpu_to_le16_compile_time ('I'),
+      grub_cpu_to_le16_compile_time (' '),
+      grub_cpu_to_le16_compile_time ('S'),
+      grub_cpu_to_le16_compile_time ('Y'),
+      grub_cpu_to_le16_compile_time ('S'),
+      grub_cpu_to_le16_compile_time ('T'),
+      grub_cpu_to_le16_compile_time ('E'),
+      grub_cpu_to_le16_compile_time ('M'),
+      0x0,
+    }
+  },
+  {
+    .type = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT,
+    .guid = GRUB_GPT_GUID_INIT (0x876c898d, 0x1b40, 0x4727, 0xa1, 0x61,
+				0xed, 0xf9, 0xb5, 0x48, 0x66, 0x74),
+    .start = grub_cpu_to_le64_compile_time (0x40),
+    .end = grub_cpu_to_le64_compile_time (0x7f),
+    .attrib = grub_cpu_to_le64_compile_time (
+	1ULL << GRUB_GPT_PART_ATTR_OFFSET_LEGACY_BIOS_BOOTABLE),
+    .name = {
+      grub_cpu_to_le16_compile_time ('B'),
+      grub_cpu_to_le16_compile_time ('I'),
+      grub_cpu_to_le16_compile_time ('O'),
+      grub_cpu_to_le16_compile_time ('S'),
+      grub_cpu_to_le16_compile_time (' '),
+      grub_cpu_to_le16_compile_time ('B'),
+      grub_cpu_to_le16_compile_time ('O'),
+      grub_cpu_to_le16_compile_time ('O'),
+      grub_cpu_to_le16_compile_time ('T'),
+      0x0,
+    }
+  },
 };
 
 /* And the backup header.  */
@@ -112,7 +157,7 @@ static const struct grub_gpt_header example_backup = {
   .magic = GRUB_GPT_HEADER_MAGIC,
   .version = GRUB_GPT_HEADER_VERSION,
   .headersize = sizeof (struct grub_gpt_header),
-  .crc32 = grub_cpu_to_le32_compile_time (0xcfaa4a27),
+  .crc32 = grub_cpu_to_le32_compile_time (0x0af785eb),
   .header_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
   .alternate_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
   .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
@@ -122,7 +167,7 @@ static const struct grub_gpt_header example_backup = {
   .partitions = grub_cpu_to_le64_compile_time (BACKUP_TABLE_SECTOR),
   .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
   .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
-  .partentry_crc32 = grub_cpu_to_le32_compile_time (0xab54d286),
+  .partentry_crc32 = grub_cpu_to_le32_compile_time (0x074e052c),
 };
 
 /* Sample protective MBR for the same 1MB disk. Note, this matches
@@ -192,6 +237,10 @@ reset_disk (struct test_data *data)
   memcpy (&data->raw->mbr, &example_pmbr, sizeof (data->raw->mbr));
   memcpy (&data->raw->primary_header, &example_primary,
 	  sizeof (data->raw->primary_header));
+  memcpy (&data->raw->primary_entries, &example_entries,
+	  sizeof (data->raw->primary_entries));
+  memcpy (&data->raw->backup_entries, &example_entries,
+	  sizeof (data->raw->backup_entries));
   memcpy (&data->raw->backup_header, &example_backup,
 	  sizeof (data->raw->backup_header));
 
@@ -270,11 +319,7 @@ read_disk (struct test_data *data)
 
   gpt = grub_gpt_read (data->dev->disk);
   if (gpt == NULL)
-    {
-      grub_print_error ();
-      grub_fatal ("grub_gpt_read failed");
-    }
-
+    grub_fatal ("grub_gpt_read failed: %s", grub_errmsg);
 
   return gpt;
 }
From ff730f68d8f9816001d4b4cff974f500f670a992 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 27 Nov 2014 16:34:21 -0800
Subject: [PATCH] gpt: add search by partition label and uuid commands

Builds on the existing filesystem search code. Only for GPT right now.
---
 Makefile.util.def                      |  2 +
 grub-core/Makefile.core.def            | 10 ++++
 grub-core/commands/search.c            | 49 ++++++++++++++++++++
 grub-core/commands/search_part_label.c |  5 ++
 grub-core/commands/search_part_uuid.c  |  5 ++
 grub-core/commands/search_wrap.c       | 12 +++++
 grub-core/lib/gpt.c                    | 64 ++++++++++++++++++++++++++
 include/grub/gpt_partition.h           | 16 +++++++
 include/grub/search.h                  |  4 ++
 tests/gpt_unit_test.c                  | 84 ++++++++++++++++++++++++++++++++++
 10 files changed, 251 insertions(+)
 create mode 100644 grub-core/commands/search_part_label.c
 create mode 100644 grub-core/commands/search_part_uuid.c

diff --git a/Makefile.util.def b/Makefile.util.def
index 9249f77be..bc0f178ff 100644
--- a/Makefile.util.def
+++ b/Makefile.util.def
@@ -1271,6 +1271,8 @@ program = {
   name = gpt_unit_test;
   common = tests/gpt_unit_test.c;
   common = tests/lib/unit_test.c;
+  common = grub-core/commands/search_part_label.c;
+  common = grub-core/commands/search_part_uuid.c;
   common = grub-core/disk/host.c;
   common = grub-core/kern/emu/hostfs.c;
   common = grub-core/lib/gpt.c;
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 4620138cb..4cce18d6d 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -1013,6 +1013,16 @@ module = {
   common = commands/search_label.c;
 };
 
+module = {
+  name = search_part_uuid;
+  common = commands/search_part_uuid.c;
+};
+
+module = {
+  name = search_part_label;
+  common = commands/search_part_label.c;
+};
+
 module = {
   name = setpci;
   common = commands/setpci.c;
diff --git a/grub-core/commands/search.c b/grub-core/commands/search.c
index 7dd32e445..09e165ed3 100644
--- a/grub-core/commands/search.c
+++ b/grub-core/commands/search.c
@@ -30,6 +30,9 @@
 #include <grub/i18n.h>
 #include <grub/disk.h>
 #include <grub/partition.h>
+#if defined(DO_SEARCH_PART_UUID) || defined(DO_SEARCH_PART_LABEL)
+#include <grub/gpt_partition.h>
+#endif
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
@@ -90,6 +93,44 @@ iterate_device (const char *name, void *data)
 	}
       grub_free (buf);
     }
+#elif defined(DO_SEARCH_PART_UUID)
+    {
+      grub_device_t dev;
+      char *quid;
+
+      dev = grub_device_open (name);
+      if (dev)
+	{
+	  if (grub_gpt_part_uuid (dev, &quid) == GRUB_ERR_NONE)
+	    {
+	      if (grub_strcasecmp (quid, ctx->key) == 0)
+		    found = 1;
+
+	      grub_free (quid);
+	    }
+
+	  grub_device_close (dev);
+	}
+    }
+#elif defined(DO_SEARCH_PART_LABEL)
+    {
+      grub_device_t dev;
+      char *quid;
+
+      dev = grub_device_open (name);
+      if (dev)
+	{
+	  if (grub_gpt_part_label (dev, &quid) == GRUB_ERR_NONE)
+	    {
+	      if (grub_strcmp (quid, ctx->key) == 0)
+		    found = 1;
+
+	      grub_free (quid);
+	    }
+
+	  grub_device_close (dev);
+	}
+    }
 #else
     {
       /* SEARCH_FS_UUID or SEARCH_LABEL */
@@ -313,6 +354,10 @@ static grub_command_t cmd;
 
 #ifdef DO_SEARCH_FILE
 GRUB_MOD_INIT(search_fs_file)
+#elif defined(DO_SEARCH_PART_UUID)
+GRUB_MOD_INIT(search_part_uuid)
+#elif defined(DO_SEARCH_PART_LABEL)
+GRUB_MOD_INIT(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_INIT(search_fs_uuid)
 #else
@@ -327,6 +372,10 @@ GRUB_MOD_INIT(search_label)
 
 #ifdef DO_SEARCH_FILE
 GRUB_MOD_FINI(search_fs_file)
+#elif defined(DO_SEARCH_PART_UUID)
+GRUB_MOD_FINI(search_part_uuid)
+#elif defined(DO_SEARCH_PART_LABEL)
+GRUB_MOD_FINI(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_FINI(search_fs_uuid)
 #else
diff --git a/grub-core/commands/search_part_label.c b/grub-core/commands/search_part_label.c
new file mode 100644
index 000000000..ca906cbd9
--- /dev/null
+++ b/grub-core/commands/search_part_label.c
@@ -0,0 +1,5 @@
+#define DO_SEARCH_PART_LABEL 1
+#define FUNC_NAME grub_search_part_label
+#define COMMAND_NAME "search.part_label"
+#define HELP_MESSAGE N_("Search devices by partition label. If VARIABLE is specified, the first device found is set to a variable.")
+#include "search.c"
diff --git a/grub-core/commands/search_part_uuid.c b/grub-core/commands/search_part_uuid.c
new file mode 100644
index 000000000..2d1d3d0d7
--- /dev/null
+++ b/grub-core/commands/search_part_uuid.c
@@ -0,0 +1,5 @@
+#define DO_SEARCH_PART_UUID 1
+#define FUNC_NAME grub_search_part_uuid
+#define COMMAND_NAME "search.part_uuid"
+#define HELP_MESSAGE N_("Search devices by partition UUID. If VARIABLE is specified, the first device found is set to a variable.")
+#include "search.c"
diff --git a/grub-core/commands/search_wrap.c b/grub-core/commands/search_wrap.c
index d7fd26b94..e3ff756df 100644
--- a/grub-core/commands/search_wrap.c
+++ b/grub-core/commands/search_wrap.c
@@ -36,6 +36,10 @@ static const struct grub_arg_option options[] =
      0, 0},
     {"fs-uuid",		'u', 0, N_("Search devices by a filesystem UUID."),
      0, 0},
+    {"part-label",	'L', 0, N_("Search devices by a partition label."),
+     0, 0},
+    {"part-uuid",	'U', 0, N_("Search devices by a partition UUID."),
+     0, 0},
     {"set",		's', GRUB_ARG_OPTION_OPTIONAL,
      N_("Set a variable to the first device found."), N_("VARNAME"),
      ARG_TYPE_STRING},
@@ -71,6 +75,8 @@ enum options
     SEARCH_FILE,
     SEARCH_LABEL,
     SEARCH_FS_UUID,
+    SEARCH_PART_LABEL,
+    SEARCH_PART_UUID,
     SEARCH_SET,
     SEARCH_NO_FLOPPY,
     SEARCH_HINT,
@@ -186,6 +192,12 @@ grub_cmd_search (grub_extcmd_context_t ctxt, int argc, char **args)
   else if (state[SEARCH_FS_UUID].set)
     grub_search_fs_uuid (id, var, state[SEARCH_NO_FLOPPY].set,
 			 hints, nhints);
+  else if (state[SEARCH_PART_LABEL].set)
+    grub_search_part_label (id, var, state[SEARCH_NO_FLOPPY].set,
+			    hints, nhints);
+  else if (state[SEARCH_PART_UUID].set)
+    grub_search_part_uuid (id, var, state[SEARCH_NO_FLOPPY].set,
+			   hints, nhints);
   else if (state[SEARCH_FILE].set)
     grub_search_fs_file (id, var, state[SEARCH_NO_FLOPPY].set, 
 			 hints, nhints);
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 9a1835b84..10a4b852d 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -18,7 +18,9 @@
  *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <grub/charset.h>
 #include <grub/crypto.h>
+#include <grub/device.h>
 #include <grub/disk.h>
 #include <grub/misc.h>
 #include <grub/mm.h>
@@ -44,6 +46,68 @@ grub_gpt_guid_to_str (grub_gpt_guid_t *guid)
 			 guid->data4[6], guid->data4[7]);
 }
 
+static grub_err_t
+grub_gpt_device_partentry (grub_device_t device,
+			   struct grub_gpt_partentry *entry)
+{
+  grub_disk_t disk = device->disk;
+  grub_partition_t p;
+  grub_err_t err;
+
+  if (!disk || !disk->partition)
+    return grub_error (GRUB_ERR_BUG, "not a partition");
+
+  if (grub_strcmp (disk->partition->partmap->name, "gpt"))
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, "not a GPT partition");
+
+  p = disk->partition;
+  disk->partition = p->parent;
+  err = grub_disk_read (disk, p->offset, p->index, sizeof (*entry), entry);
+  disk->partition = p;
+
+  return err;
+}
+
+grub_err_t
+grub_gpt_part_label (grub_device_t device, char **label)
+{
+  struct grub_gpt_partentry entry;
+  const grub_size_t name_len = ARRAY_SIZE (entry.name);
+  const grub_size_t label_len = name_len * GRUB_MAX_UTF8_PER_UTF16 + 1;
+  grub_size_t i;
+  grub_uint8_t *end;
+
+  if (grub_gpt_device_partentry (device, &entry))
+    return grub_errno;
+
+  *label = grub_malloc (label_len);
+  if (!*label)
+    return grub_errno;
+
+  for (i = 0; i < name_len; i++)
+    entry.name[i] = grub_le_to_cpu16 (entry.name[i]);
+
+  end = grub_utf16_to_utf8 ((grub_uint8_t *) *label, entry.name, name_len);
+  *end = '\0';
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_part_uuid (grub_device_t device, char **uuid)
+{
+  struct grub_gpt_partentry entry;
+
+  if (grub_gpt_device_partentry (device, &entry))
+    return grub_errno;
+
+  *uuid = grub_gpt_guid_to_str (&entry.guid);
+  if (!*uuid)
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
 static grub_uint64_t
 grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
 {
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 1142317e3..8ff62d67f 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -49,6 +49,10 @@ char * grub_gpt_guid_to_str (grub_gpt_guid_t *guid);
   GRUB_GPT_GUID_INIT (0x0, 0x0, 0x0,  \
       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
 
+#define GRUB_GPT_PARTITION_TYPE_EFI_SYSTEM \
+  GRUB_GPT_GUID_INIT (0xc12a7328, 0xf81f, 0x11d2, \
+      0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b)
+
 #define GRUB_GPT_PARTITION_TYPE_BIOS_BOOT \
   GRUB_GPT_GUID_INIT (0x21686148, 0x6449, 0x6e6f, \
       0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49)
@@ -216,4 +220,16 @@ grub_err_t grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr);
 grub_err_t grub_gpt_header_check (struct grub_gpt_header *gpt,
 				  unsigned int log_sector_size);
 
+
+/* Utilities for simple partition data lookups, usage is intended to
+ * be similar to fs->label and fs->uuid functions.  */
+
+/* Return the partition label of the device DEVICE in LABEL.
+ * The label is in a new buffer and should be freed by the caller.  */
+grub_err_t grub_gpt_part_label (grub_device_t device, char **label);
+
+/* Return the partition uuid of the device DEVICE in UUID.
+ * The label is in a new buffer and should be freed by the caller.  */
+grub_err_t grub_gpt_part_uuid (grub_device_t device, char **uuid);
+
 #endif /* ! GRUB_GPT_PARTITION_HEADER */
diff --git a/include/grub/search.h b/include/grub/search.h
index d80347df3..c2f40abe9 100644
--- a/include/grub/search.h
+++ b/include/grub/search.h
@@ -25,5 +25,9 @@ void grub_search_fs_uuid (const char *key, const char *var, int no_floppy,
 			  char **hints, unsigned nhints);
 void grub_search_label (const char *key, const char *var, int no_floppy,
 			char **hints, unsigned nhints);
+void grub_search_part_uuid (const char *key, const char *var, int no_floppy,
+			    char **hints, unsigned nhints);
+void grub_search_part_label (const char *key, const char *var, int no_floppy,
+			     char **hints, unsigned nhints);
 
 #endif
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index 5692a5a52..deb55a926 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -21,10 +21,12 @@
 #include <grub/disk.h>
 #include <grub/emu/hostdisk.h>
 #include <grub/emu/misc.h>
+#include <grub/env.h>
 #include <grub/err.h>
 #include <grub/gpt_partition.h>
 #include <grub/msdos_partition.h>
 #include <grub/lib/hexdump.h>
+#include <grub/search.h>
 #include <grub/test.h>
 
 #include <errno.h>
@@ -534,6 +536,84 @@ repair_test (void)
 
   close_disk (&data);
 }
+
+static void
+search_label_test (void)
+{
+  struct test_data data;
+  const char *test_result;
+  char *expected_result;
+
+  open_disk (&data);
+
+  expected_result = grub_xasprintf ("%s,gpt1", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_label ("EFI SYSTEM", "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  expected_result = grub_xasprintf ("%s,gpt2", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_label ("BIOS BOOT", "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  grub_env_unset ("test_result");
+  grub_search_part_label ("bogus name", "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result == NULL,
+		    "unexpected device: %s", test_result);
+  grub_test_assert (grub_errno == GRUB_ERR_FILE_NOT_FOUND,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
+static void
+search_uuid_test (void)
+{
+  struct test_data data;
+  const char gpt1_uuid[] = "A0F1792E-B4CE-4136-BCF2-1AFC133C2828";
+  const char gpt2_uuid[] = "876c898d-1b40-4727-a161-edf9b5486674";
+  const char bogus_uuid[] = "1534c928-c50e-4866-9daf-6a9fd7918a76";
+  const char *test_result;
+  char *expected_result;
+
+  open_disk (&data);
+
+  expected_result = grub_xasprintf ("%s,gpt1", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_uuid (gpt1_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  expected_result = grub_xasprintf ("%s,gpt2", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_uuid (gpt2_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  grub_env_unset ("test_result");
+  grub_search_part_uuid (bogus_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result == NULL,
+		    "unexpected device: %s", test_result);
+  grub_test_assert (grub_errno == GRUB_ERR_FILE_NOT_FOUND,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
 void
 grub_unit_test_init (void)
 {
@@ -546,6 +626,8 @@ grub_unit_test_init (void)
   grub_test_register ("gpt_read_invalid_test", read_invalid_entries_test);
   grub_test_register ("gpt_read_fallback_test", read_fallback_test);
   grub_test_register ("gpt_repair_test", repair_test);
+  grub_test_register ("gpt_search_label_test", search_label_test);
+  grub_test_register ("gpt_search_uuid_test", search_uuid_test);
 }
 
 void
@@ -557,5 +639,7 @@ grub_unit_test_fini (void)
   grub_test_unregister ("gpt_read_invalid_test");
   grub_test_unregister ("gpt_read_fallback_test");
   grub_test_unregister ("gpt_repair_test");
+  grub_test_unregister ("gpt_search_label_test");
+  grub_test_unregister ("gpt_search_uuid_test");
   grub_fini_all ();
 }
From 57d264518a2a01730c1ba14d058d2a5573d6bd15 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Fri, 31 Jul 2015 15:03:11 -0700
Subject: [PATCH] gpt: clean up little-endian crc32 computation

 - Remove problematic cast from *uint8_t to *uint32_t (alignment issue).
 - Remove dynamic allocation and associated error handling paths.
 - Match parameter ordering to existing grub_crypto_hash function.
---
 grub-core/lib/gpt.c | 51 +++++++++++++--------------------------------------
 1 file changed, 13 insertions(+), 38 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 10a4b852d..aedc4f7a1 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -122,45 +122,29 @@ grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
   return sectors;
 }
 
-static grub_err_t
-grub_gpt_lecrc32 (void *data, grub_size_t len, grub_uint32_t *crc)
+static void
+grub_gpt_lecrc32 (grub_uint32_t *crc, const void *data, grub_size_t len)
 {
-  grub_uint8_t *crc32_context;
-
-  crc32_context = grub_zalloc (GRUB_MD_CRC32->contextsize);
-  if (!crc32_context)
-    return grub_errno;
+  grub_uint32_t crc32_val;
 
-  GRUB_MD_CRC32->init (crc32_context);
-  GRUB_MD_CRC32->write (crc32_context, data, len);
-  GRUB_MD_CRC32->final (crc32_context);
+  grub_crypto_hash (GRUB_MD_CRC32, &crc32_val, data, len);
 
   /* GRUB_MD_CRC32 always uses big endian, gpt is always little.  */
-  *crc = grub_swap_bytes32 (*(grub_uint32_t *)
-			    GRUB_MD_CRC32->read (crc32_context));
-
-  grub_free (crc32_context);
-
-  return GRUB_ERR_NONE;
+  *crc = grub_swap_bytes32 (crc32_val);
 }
 
-static grub_err_t
-grub_gpt_header_lecrc32 (struct grub_gpt_header *header, grub_uint32_t *crc)
+static void
+grub_gpt_header_lecrc32 (grub_uint32_t *crc, struct grub_gpt_header *header)
 {
   grub_uint32_t old, new;
-  grub_err_t err;
 
   /* crc32 must be computed with the field cleared.  */
   old = header->crc32;
   header->crc32 = 0;
-  err = grub_gpt_lecrc32 (header, sizeof (*header), &new);
+  grub_gpt_lecrc32 (&new, header, sizeof (*header));
   header->crc32 = old;
 
-  if (err)
-    return err;
-
   *crc = new;
-  return GRUB_ERR_NONE;
 }
 
 /* Make sure the MBR is a protective MBR and not a normal MBR.  */
@@ -192,9 +176,7 @@ grub_gpt_header_check (struct grub_gpt_header *gpt,
   if (gpt->version != GRUB_GPT_HEADER_VERSION)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "unknown GPT version");
 
-  if (grub_gpt_header_lecrc32 (gpt, &crc))
-    return grub_errno;
-
+  grub_gpt_header_lecrc32 (&crc, gpt);
   if (gpt->crc32 != crc)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header crc32");
 
@@ -289,9 +271,7 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
   if (grub_disk_read (disk, addr, 0, entries_size, entries))
     goto fail;
 
-  if (grub_gpt_lecrc32 (entries, entries_size, &crc))
-    goto fail;
-
+  grub_gpt_lecrc32 (&crc, entries, entries_size);
   if (crc != header->partentry_crc32)
     {
       grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry crc32");
@@ -433,17 +413,12 @@ grub_gpt_update_checksums (grub_gpt_t gpt)
   gpt->backup.headersize =
     grub_cpu_to_le32_compile_time (sizeof (gpt->backup));
 
-  if (grub_gpt_lecrc32 (gpt->entries, gpt->entries_size, &crc))
-    return grub_errno;
-
+  grub_gpt_lecrc32 (&crc, gpt->entries, gpt->entries_size);
   gpt->primary.partentry_crc32 = crc;
   gpt->backup.partentry_crc32 = crc;
 
-  if (grub_gpt_header_lecrc32 (&gpt->primary, &gpt->primary.crc32))
-    return grub_errno;
-
-  if (grub_gpt_header_lecrc32 (&gpt->backup, &gpt->backup.crc32))
-    return grub_errno;
+  grub_gpt_header_lecrc32 (&gpt->primary.crc32, &gpt->primary);
+  grub_gpt_header_lecrc32 (&gpt->backup.crc32, &gpt->backup);
 
   return GRUB_ERR_NONE;
 }
From 8ec39207e9c81685459a9901ee2c057924eb8ec0 Mon Sep 17 00:00:00 2001
From: Alex Crawford <alex.crawford@coreos.com>
Date: Mon, 31 Aug 2015 15:23:39 -0700
Subject: [PATCH] gpt: minor cleanup

---
 include/grub/gpt_partition.h |  2 +-
 tests/gpt_unit_test.c        | 12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 8ff62d67f..21359f08a 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -229,7 +229,7 @@ grub_err_t grub_gpt_header_check (struct grub_gpt_header *gpt,
 grub_err_t grub_gpt_part_label (grub_device_t device, char **label);
 
 /* Return the partition uuid of the device DEVICE in UUID.
- * The label is in a new buffer and should be freed by the caller.  */
+ * The uuid is in a new buffer and should be freed by the caller.  */
 grub_err_t grub_gpt_part_uuid (grub_device_t device, char **uuid);
 
 #endif /* ! GRUB_GPT_PARTITION_HEADER */
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index deb55a926..7a1af46e1 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -538,7 +538,7 @@ repair_test (void)
 }
 
 static void
-search_label_test (void)
+search_part_label_test (void)
 {
   struct test_data data;
   const char *test_result;
@@ -575,7 +575,7 @@ search_label_test (void)
 }
 
 static void
-search_uuid_test (void)
+search_part_uuid_test (void)
 {
   struct test_data data;
   const char gpt1_uuid[] = "A0F1792E-B4CE-4136-BCF2-1AFC133C2828";
@@ -626,8 +626,8 @@ grub_unit_test_init (void)
   grub_test_register ("gpt_read_invalid_test", read_invalid_entries_test);
   grub_test_register ("gpt_read_fallback_test", read_fallback_test);
   grub_test_register ("gpt_repair_test", repair_test);
-  grub_test_register ("gpt_search_label_test", search_label_test);
-  grub_test_register ("gpt_search_uuid_test", search_uuid_test);
+  grub_test_register ("gpt_search_part_label_test", search_part_label_test);
+  grub_test_register ("gpt_search_uuid_test", search_part_uuid_test);
 }
 
 void
@@ -639,7 +639,7 @@ grub_unit_test_fini (void)
   grub_test_unregister ("gpt_read_invalid_test");
   grub_test_unregister ("gpt_read_fallback_test");
   grub_test_unregister ("gpt_repair_test");
-  grub_test_unregister ("gpt_search_label_test");
-  grub_test_unregister ("gpt_search_uuid_test");
+  grub_test_unregister ("gpt_search_part_label_test");
+  grub_test_unregister ("gpt_search_part_uuid_test");
   grub_fini_all ();
 }
From 786e2f7da69a2a238390cb56f394c102c3938f09 Mon Sep 17 00:00:00 2001
From: Alex Crawford <alex.crawford@coreos.com>
Date: Mon, 31 Aug 2015 15:15:48 -0700
Subject: [PATCH] gpt: add search by disk uuid command

---
 Makefile.util.def                     |  1 +
 grub-core/Makefile.core.def           |  5 +++++
 grub-core/commands/search.c           | 28 ++++++++++++++++++++++++++--
 grub-core/commands/search_disk_uuid.c |  5 +++++
 grub-core/commands/search_wrap.c      |  6 ++++++
 grub-core/lib/gpt.c                   | 21 +++++++++++++++++++++
 include/grub/gpt_partition.h          |  4 ++++
 include/grub/search.h                 |  2 ++
 tests/gpt_unit_test.c                 | 33 +++++++++++++++++++++++++++++++++
 9 files changed, 103 insertions(+), 2 deletions(-)
 create mode 100644 grub-core/commands/search_disk_uuid.c

diff --git a/Makefile.util.def b/Makefile.util.def
index bc0f178ff..4b1b4c410 100644
--- a/Makefile.util.def
+++ b/Makefile.util.def
@@ -1273,6 +1273,7 @@ program = {
   common = tests/lib/unit_test.c;
   common = grub-core/commands/search_part_label.c;
   common = grub-core/commands/search_part_uuid.c;
+  common = grub-core/commands/search_disk_uuid.c;
   common = grub-core/disk/host.c;
   common = grub-core/kern/emu/hostfs.c;
   common = grub-core/lib/gpt.c;
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 4cce18d6d..ae68b75a8 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -1023,6 +1023,11 @@ module = {
   common = commands/search_part_label.c;
 };
 
+module = {
+  name = search_disk_uuid;
+  common = commands/search_disk_uuid.c;
+};
+
 module = {
   name = setpci;
   common = commands/setpci.c;
diff --git a/grub-core/commands/search.c b/grub-core/commands/search.c
index 09e165ed3..83837b564 100644
--- a/grub-core/commands/search.c
+++ b/grub-core/commands/search.c
@@ -30,7 +30,8 @@
 #include <grub/i18n.h>
 #include <grub/disk.h>
 #include <grub/partition.h>
-#if defined(DO_SEARCH_PART_UUID) || defined(DO_SEARCH_PART_LABEL)
+#if defined(DO_SEARCH_PART_UUID) || defined(DO_SEARCH_PART_LABEL) || \
+    defined(DO_SEARCH_DISK_UUID)
 #include <grub/gpt_partition.h>
 #endif
 
@@ -69,7 +70,7 @@ iterate_device (const char *name, void *data)
       name[0] == 'f' && name[1] == 'd' && name[2] >= '0' && name[2] <= '9')
     return 1;
 
-#ifdef DO_SEARCH_FS_UUID
+#if defined(DO_SEARCH_FS_UUID) || defined(DO_SEARCH_DISK_UUID)
 #define compare_fn grub_strcasecmp
 #else
 #define compare_fn grub_strcmp
@@ -128,6 +129,25 @@ iterate_device (const char *name, void *data)
 	      grub_free (quid);
 	    }
 
+	  grub_device_close (dev);
+	}
+    }
+#elif defined(DO_SEARCH_DISK_UUID)
+    {
+      grub_device_t dev;
+      char *quid;
+
+      dev = grub_device_open (name);
+      if (dev)
+	{
+	  if (grub_gpt_disk_uuid (dev, &quid) == GRUB_ERR_NONE)
+	    {
+	      if (grub_strcmp (quid, ctx->key) == 0)
+		found = 1;
+
+	      grub_free (quid);
+	    }
+
 	  grub_device_close (dev);
 	}
     }
@@ -360,6 +380,8 @@ GRUB_MOD_INIT(search_part_uuid)
 GRUB_MOD_INIT(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_INIT(search_fs_uuid)
+#elif defined (DO_SEARCH_DISK_UUID)
+GRUB_MOD_INIT(search_disk_uuid)
 #else
 GRUB_MOD_INIT(search_label)
 #endif
@@ -378,6 +400,8 @@ GRUB_MOD_FINI(search_part_uuid)
 GRUB_MOD_FINI(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_FINI(search_fs_uuid)
+#elif defined (DO_SEARCH_DISK_UUID)
+GRUB_MOD_FINI(search_disk_uuid)
 #else
 GRUB_MOD_FINI(search_label)
 #endif
diff --git a/grub-core/commands/search_disk_uuid.c b/grub-core/commands/search_disk_uuid.c
new file mode 100644
index 000000000..fba96f6b8
--- /dev/null
+++ b/grub-core/commands/search_disk_uuid.c
@@ -0,0 +1,5 @@
+#define DO_SEARCH_DISK_UUID 1
+#define FUNC_NAME grub_search_disk_uuid
+#define COMMAND_NAME "search.disk_uuid"
+#define HELP_MESSAGE N_("Search devices by disk UUID. If VARIABLE is specified, the first device found is set to a variable.")
+#include "search.c"
diff --git a/grub-core/commands/search_wrap.c b/grub-core/commands/search_wrap.c
index e3ff756df..d931c56c5 100644
--- a/grub-core/commands/search_wrap.c
+++ b/grub-core/commands/search_wrap.c
@@ -40,6 +40,8 @@ static const struct grub_arg_option options[] =
      0, 0},
     {"part-uuid",	'U', 0, N_("Search devices by a partition UUID."),
      0, 0},
+    {"disk-uuid",	'U', 0, N_("Search devices by a disk UUID."),
+     0, 0},
     {"set",		's', GRUB_ARG_OPTION_OPTIONAL,
      N_("Set a variable to the first device found."), N_("VARNAME"),
      ARG_TYPE_STRING},
@@ -77,6 +79,7 @@ enum options
     SEARCH_FS_UUID,
     SEARCH_PART_LABEL,
     SEARCH_PART_UUID,
+    SEARCH_DISK_UUID,
     SEARCH_SET,
     SEARCH_NO_FLOPPY,
     SEARCH_HINT,
@@ -198,6 +201,9 @@ grub_cmd_search (grub_extcmd_context_t ctxt, int argc, char **args)
   else if (state[SEARCH_PART_UUID].set)
     grub_search_part_uuid (id, var, state[SEARCH_NO_FLOPPY].set,
 			   hints, nhints);
+  else if (state[SEARCH_DISK_UUID].set)
+    grub_search_disk_uuid (id, var, state[SEARCH_NO_FLOPPY].set,
+			   hints, nhints);
   else if (state[SEARCH_FILE].set)
     grub_search_fs_file (id, var, state[SEARCH_NO_FLOPPY].set, 
 			 hints, nhints);
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index aedc4f7a1..e162bafd3 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -108,6 +108,27 @@ grub_gpt_part_uuid (grub_device_t device, char **uuid)
   return GRUB_ERR_NONE;
 }
 
+grub_err_t
+grub_gpt_disk_uuid (grub_device_t device, char **uuid)
+{
+  grub_gpt_t gpt = grub_gpt_read (device->disk);
+  if (!gpt)
+    goto done;
+
+  grub_errno = GRUB_ERR_NONE;
+
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    *uuid = grub_gpt_guid_to_str (&gpt->primary.guid);
+  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    *uuid = grub_gpt_guid_to_str (&gpt->backup.guid);
+  else
+    grub_errno = grub_error (GRUB_ERR_BUG, "No valid GPT header");
+
+done:
+  grub_gpt_free (gpt);
+  return grub_errno;
+}
+
 static grub_uint64_t
 grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
 {
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 21359f08a..4a6ed25b3 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -232,4 +232,8 @@ grub_err_t grub_gpt_part_label (grub_device_t device, char **label);
  * The uuid is in a new buffer and should be freed by the caller.  */
 grub_err_t grub_gpt_part_uuid (grub_device_t device, char **uuid);
 
+/* Return the disk uuid of the device DEVICE in UUID.
+ * The uuid is in a new buffer and should be freed by the caller.  */
+grub_err_t grub_gpt_disk_uuid (grub_device_t device, char **uuid);
+
 #endif /* ! GRUB_GPT_PARTITION_HEADER */
diff --git a/include/grub/search.h b/include/grub/search.h
index c2f40abe9..7f69d25d1 100644
--- a/include/grub/search.h
+++ b/include/grub/search.h
@@ -29,5 +29,7 @@ void grub_search_part_uuid (const char *key, const char *var, int no_floppy,
 			    char **hints, unsigned nhints);
 void grub_search_part_label (const char *key, const char *var, int no_floppy,
 			     char **hints, unsigned nhints);
+void grub_search_disk_uuid (const char *key, const char *var, int no_floppy,
+			    char **hints, unsigned nhints);
 
 #endif
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index 7a1af46e1..60f601729 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -614,6 +614,37 @@ search_part_uuid_test (void)
   close_disk (&data);
 }
 
+static void
+search_disk_uuid_test (void)
+{
+  struct test_data data;
+  const char disk_uuid[] = "69c131ad-67d6-46c6-93c4-124c755256ac";
+  const char bogus_uuid[] = "1534c928-c50e-4866-9daf-6a9fd7918a76";
+  const char *test_result;
+  char *expected_result;
+
+  open_disk (&data);
+
+  expected_result = grub_xasprintf ("%s", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_disk_uuid (disk_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  grub_env_unset ("test_result");
+  grub_search_disk_uuid (bogus_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result == NULL,
+		    "unexpected device: %s", test_result);
+  grub_test_assert (grub_errno == GRUB_ERR_FILE_NOT_FOUND,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
 void
 grub_unit_test_init (void)
 {
@@ -628,6 +659,7 @@ grub_unit_test_init (void)
   grub_test_register ("gpt_repair_test", repair_test);
   grub_test_register ("gpt_search_part_label_test", search_part_label_test);
   grub_test_register ("gpt_search_uuid_test", search_part_uuid_test);
+  grub_test_register ("gpt_search_disk_uuid_test", search_disk_uuid_test);
 }
 
 void
@@ -641,5 +673,6 @@ grub_unit_test_fini (void)
   grub_test_unregister ("gpt_repair_test");
   grub_test_unregister ("gpt_search_part_label_test");
   grub_test_unregister ("gpt_search_part_uuid_test");
+  grub_test_unregister ("gpt_search_disk_uuid_test");
   grub_fini_all ();
 }
From b993a3cec81275809b5a9b55b10c170a8f862bfe Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Mon, 25 Jul 2016 14:59:29 -0700
Subject: [PATCH] gpt: do not use disk sizes GRUB will reject as invalid later
 on

GRUB assumes that no disk is ever larger than 1EiB and rejects
reads/writes to such locations. Unfortunately this is not conveyed in
the usual way with the special GRUB_DISK_SIZE_UNKNOWN value.
---
 grub-core/lib/gpt.c | 26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index e162bafd3..3e17f2771 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -143,6 +143,28 @@ grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
   return sectors;
 }
 
+/* Copied from grub-core/kern/disk_common.c grub_disk_adjust_range so we can
+ * avoid attempting to use disk->total_sectors when GRUB won't let us.
+ * TODO: Why is disk->total_sectors not set to GRUB_DISK_SIZE_UNKNOWN?  */
+static int
+grub_gpt_disk_size_valid (grub_disk_t disk)
+{
+  grub_disk_addr_t total_sectors;
+
+  /* Transform total_sectors to number of 512B blocks.  */
+  total_sectors = disk->total_sectors << (disk->log_sector_size - GRUB_DISK_SECTOR_BITS);
+
+  /* Some drivers have problems with disks above reasonable.
+     Treat unknown as 1EiB disk. While on it, clamp the size to 1EiB.
+     Just one condition is enough since GRUB_DISK_UNKNOWN_SIZE << ls is always
+     above 9EiB.
+  */
+  if (total_sectors > (1ULL << 51))
+    return 0;
+
+  return 1;
+}
+
 static void
 grub_gpt_lecrc32 (grub_uint32_t *crc, const void *data, grub_size_t len)
 {
@@ -242,7 +264,7 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
   grub_disk_addr_t addr;
 
   /* Assumes gpt->log_sector_size == disk->log_sector_size  */
-  if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN)
+  if (grub_gpt_disk_size_valid(disk))
     sector = disk->total_sectors - 1;
   else if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
     sector = grub_le_to_cpu64 (gpt->primary.alternate_lba);
@@ -394,7 +416,7 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
     return grub_error (GRUB_ERR_BUG, "No valid GPT header");
 
   /* Relocate backup to end if disk whenever possible.  */
-  if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN)
+  if (grub_gpt_disk_size_valid(disk))
     backup_header = disk->total_sectors - 1;
 
   backup_entries = backup_header -
From ebc7bbaa181bcfc381b1ddad236e0ce68655de68 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 10 Aug 2016 18:26:03 -0700
Subject: [PATCH] gpt: add verbose debug logging

---
 grub-core/lib/gpt.c | 117 ++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 109 insertions(+), 8 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 3e17f2771..c2821b563 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -207,6 +207,18 @@ grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr)
   return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid protective MBR");
 }
 
+static grub_uint64_t
+grub_gpt_entries_sectors (struct grub_gpt_header *gpt,
+			  unsigned int log_sector_size)
+{
+  grub_uint64_t sector_bytes, entries_bytes;
+
+  sector_bytes = 1ULL << log_sector_size;
+  entries_bytes = (grub_uint64_t) grub_le_to_cpu32 (gpt->maxpart) *
+		  (grub_uint64_t) grub_le_to_cpu32 (gpt->partentry_size);
+  return grub_divmod64(entries_bytes + sector_bytes - 1, sector_bytes, NULL);
+}
+
 grub_err_t
 grub_gpt_header_check (struct grub_gpt_header *gpt,
 		       unsigned int log_sector_size)
@@ -236,6 +248,64 @@ grub_gpt_header_check (struct grub_gpt_header *gpt,
   return GRUB_ERR_NONE;
 }
 
+static grub_err_t
+grub_gpt_check_primary (grub_gpt_t gpt)
+{
+  grub_uint64_t backup, primary, entries, entries_len, start, end;
+
+  primary = grub_le_to_cpu64 (gpt->primary.header_lba);
+  backup = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+  entries = grub_le_to_cpu64 (gpt->primary.partitions);
+  entries_len = grub_gpt_entries_sectors(&gpt->primary, gpt->log_sector_size);
+  start = grub_le_to_cpu64 (gpt->primary.start);
+  end = grub_le_to_cpu64 (gpt->primary.end);
+
+  grub_dprintf ("gpt", "Primary GPT layout:\n"
+		"primary header = 0x%llx backup header = 0x%llx\n"
+		"entries location = 0x%llx length = 0x%llx\n"
+		"first usable = 0x%llx last usable = 0x%llx\n",
+		(unsigned long long) primary,
+		(unsigned long long) backup,
+		(unsigned long long) entries,
+		(unsigned long long) entries_len,
+		(unsigned long long) start,
+		(unsigned long long) end);
+
+  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_check_backup (grub_gpt_t gpt)
+{
+  grub_uint64_t backup, primary, entries, entries_len, start, end;
+
+  backup = grub_le_to_cpu64 (gpt->backup.header_lba);
+  primary = grub_le_to_cpu64 (gpt->backup.alternate_lba);
+  entries = grub_le_to_cpu64 (gpt->backup.partitions);
+  entries_len = grub_gpt_entries_sectors(&gpt->backup, gpt->log_sector_size);
+  start = grub_le_to_cpu64 (gpt->backup.start);
+  end = grub_le_to_cpu64 (gpt->backup.end);
+
+  grub_dprintf ("gpt", "Backup GPT layout:\n"
+		"primary header = 0x%llx backup header = 0x%llx\n"
+		"entries location = 0x%llx length = 0x%llx\n"
+		"first usable = 0x%llx last usable = 0x%llx\n",
+		(unsigned long long) primary,
+		(unsigned long long) backup,
+		(unsigned long long) entries,
+		(unsigned long long) entries_len,
+		(unsigned long long) start,
+		(unsigned long long) end);
+
+  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
 static grub_err_t
 grub_gpt_read_primary (grub_disk_t disk, grub_gpt_t gpt)
 {
@@ -246,11 +316,13 @@ grub_gpt_read_primary (grub_disk_t disk, grub_gpt_t gpt)
    * but eventually this code should match the existing behavior.  */
   gpt->log_sector_size = disk->log_sector_size;
 
+  grub_dprintf ("gpt", "reading primary GPT from sector 0x1\n");
+
   addr = grub_gpt_sector_to_addr (gpt, 1);
   if (grub_disk_read (disk, addr, 0, sizeof (gpt->primary), &gpt->primary))
     return grub_errno;
 
-  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+  if (grub_gpt_check_primary (gpt))
     return grub_errno;
 
   gpt->status |= GRUB_GPT_PRIMARY_HEADER_VALID;
@@ -272,11 +344,14 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
     return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 		       "Unable to locate backup GPT");
 
+  grub_dprintf ("gpt", "reading backup GPT from sector 0x%llx\n",
+		(unsigned long long) sector);
+
   addr = grub_gpt_sector_to_addr (gpt, sector);
   if (grub_disk_read (disk, addr, 0, sizeof (gpt->backup), &gpt->backup))
     return grub_errno;
 
-  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+  if (grub_gpt_check_backup (gpt))
     return grub_errno;
 
   gpt->status |= GRUB_GPT_BACKUP_HEADER_VALID;
@@ -289,6 +364,7 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
 {
   struct grub_gpt_partentry *entries = NULL;
   grub_uint32_t count, size, crc;
+  grub_uint64_t sector;
   grub_disk_addr_t addr;
   grub_size_t entries_size;
 
@@ -310,7 +386,12 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
   if (!entries)
     goto fail;
 
-  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->partitions));
+  sector = grub_le_to_cpu64 (header->partitions);
+  grub_dprintf ("gpt", "reading GPT %lu entries from sector 0x%llx\n",
+		(unsigned long) count,
+		(unsigned long long) sector);
+
+  addr = grub_gpt_sector_to_addr (gpt, sector);
   if (grub_disk_read (disk, addr, 0, entries_size, entries))
     goto fail;
 
@@ -336,6 +417,8 @@ grub_gpt_read (grub_disk_t disk)
 {
   grub_gpt_t gpt;
 
+  grub_dprintf ("gpt", "reading GPT from %s\n", disk->name);
+
   gpt = grub_zalloc (sizeof (*gpt));
   if (!gpt)
     goto fail;
@@ -369,12 +452,18 @@ grub_gpt_read (grub_disk_t disk)
   /* Similarly, favor the value or error from the primary table.  */
   if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID &&
       !grub_gpt_read_entries (disk, gpt, &gpt->backup))
-    gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
+    {
+      grub_dprintf ("gpt", "read valid backup GPT from %s\n", disk->name);
+      gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
+    }
 
   grub_errno = GRUB_ERR_NONE;
   if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID &&
       !grub_gpt_read_entries (disk, gpt, &gpt->primary))
-    gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
+    {
+      grub_dprintf ("gpt", "read valid primary GPT from %s\n", disk->name);
+      gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
+    }
 
   if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
       gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID)
@@ -394,21 +483,25 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 {
   grub_uint64_t backup_header, backup_entries;
 
+  grub_dprintf ("gpt", "repairing GPT for %s\n", disk->name);
+
   if (disk->log_sector_size != gpt->log_sector_size)
     return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 		       "GPT sector size must match disk sector size");
 
   if (!(gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
-        gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID))
+	gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID))
     return grub_error (GRUB_ERR_BUG, "No valid GPT entries");
 
   if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
     {
+      grub_dprintf ("gpt", "primary GPT header is valid\n");
       backup_header = grub_le_to_cpu64 (gpt->primary.alternate_lba);
       grub_memcpy (&gpt->backup, &gpt->primary, sizeof (gpt->backup));
     }
   else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
     {
+      grub_dprintf ("gpt", "backup GPT header is valid\n");
       backup_header = grub_le_to_cpu64 (gpt->backup.header_lba);
       grub_memcpy (&gpt->primary, &gpt->backup, sizeof (gpt->primary));
     }
@@ -418,9 +511,13 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   /* Relocate backup to end if disk whenever possible.  */
   if (grub_gpt_disk_size_valid(disk))
     backup_header = disk->total_sectors - 1;
+  grub_dprintf ("gpt", "backup GPT header will be located at 0x%llx\n",
+		(unsigned long long) backup_header);
 
   backup_entries = backup_header -
     grub_gpt_size_to_sectors (gpt, gpt->entries_size);
+  grub_dprintf ("gpt", "backup GPT entries will be located at 0x%llx\n",
+		(unsigned long long) backup_entries);
 
   /* Update/fixup header and partition table locations.  */
   gpt->primary.header_lba = grub_cpu_to_le64_compile_time (1);
@@ -435,13 +532,15 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
     return grub_errno;
 
   /* Sanity check.  */
-  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+  if (grub_gpt_check_primary (gpt))
     return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
 
-  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+  if (grub_gpt_check_backup (gpt))
     return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
 
   gpt->status |= GRUB_GPT_BOTH_VALID;
+  grub_dprintf ("gpt", "repairing GPT for %s successful\n", disk->name);
+
   return GRUB_ERR_NONE;
 }
 
@@ -497,9 +596,11 @@ grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt)
   if (!(gpt->status & GRUB_GPT_BOTH_VALID))
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "Invalid GPT data");
 
+  grub_dprintf ("gpt", "writing primary GPT to %s\n", disk->name);
   if (grub_gpt_write_table (disk, gpt, &gpt->primary))
     return grub_errno;
 
+  grub_dprintf ("gpt", "writing backup GPT to %s\n", disk->name);
   if (grub_gpt_write_table (disk, gpt, &gpt->backup))
     return grub_errno;
 
From e7ae87c15b57c8bac757df45a83351c5c7a9cd10 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 10 Aug 2016 18:26:03 -0700
Subject: [PATCH] gpt: improve validation of GPT headers

Adds basic validation of all the disk locations in the headers, reducing
the chance of corrupting weird locations on disk.
---
 grub-core/lib/gpt.c | 48 ++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 48 insertions(+)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index c2821b563..f83fe29ac 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -224,6 +224,7 @@ grub_gpt_header_check (struct grub_gpt_header *gpt,
 		       unsigned int log_sector_size)
 {
   grub_uint32_t crc = 0, size;
+  grub_uint64_t start, end;
 
   if (grub_memcmp (gpt->magic, grub_gpt_magic, sizeof (grub_gpt_magic)) != 0)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT signature");
@@ -245,9 +246,35 @@ grub_gpt_header_check (struct grub_gpt_header *gpt,
   if (size < 128 || size % 128)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry size");
 
+  /* And of course there better be some space for partitions!  */
+  start = grub_le_to_cpu64 (gpt->start);
+  end = grub_le_to_cpu64 (gpt->end);
+  if (start > end)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid usable sectors");
+
   return GRUB_ERR_NONE;
 }
 
+static int
+grub_gpt_headers_equal (grub_gpt_t gpt)
+{
+  /* Assume headers passed grub_gpt_header_check so skip magic and version.
+   * Individual fields must be checked instead of just using memcmp because
+   * crc32, header, alternate, and partitions will all normally differ.  */
+
+  if (gpt->primary.headersize != gpt->backup.headersize ||
+      gpt->primary.header_lba != gpt->backup.alternate_lba ||
+      gpt->primary.start != gpt->backup.start ||
+      gpt->primary.end != gpt->backup.end ||
+      gpt->primary.maxpart != gpt->backup.maxpart ||
+      gpt->primary.partentry_size != gpt->backup.partentry_size ||
+      gpt->primary.partentry_crc32 != gpt->backup.partentry_crc32)
+    return 0;
+
+  return grub_memcmp(&gpt->primary.guid, &gpt->backup.guid,
+                     sizeof(grub_gpt_guid_t)) == 0;
+}
+
 static grub_err_t
 grub_gpt_check_primary (grub_gpt_t gpt)
 {
@@ -273,6 +300,12 @@ grub_gpt_check_primary (grub_gpt_t gpt)
 
   if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
     return grub_errno;
+  if (primary != 1)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid primary GPT LBA");
+  if (entries <= 1 || entries+entries_len > start)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid entries location");
+  if (backup <= end)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
 
   return GRUB_ERR_NONE;
 }
@@ -302,6 +335,12 @@ grub_gpt_check_backup (grub_gpt_t gpt)
 
   if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
     return grub_errno;
+  if (primary != 1)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid primary GPT LBA");
+  if (entries <= end || entries+entries_len > backup)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid entries location");
+  if (backup <= end)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
 
   return GRUB_ERR_NONE;
 }
@@ -354,6 +393,15 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
   if (grub_gpt_check_backup (gpt))
     return grub_errno;
 
+  /* Ensure the backup header thinks it is located where we found it.  */
+  if (grub_le_to_cpu64 (gpt->backup.header_lba) != sector)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
+
+  /* If both primary and backup are valid but differ prefer the primary.  */
+  if ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) &&
+      !grub_gpt_headers_equal(gpt))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "backup GPT of of sync");
+
   gpt->status |= GRUB_GPT_BACKUP_HEADER_VALID;
   return GRUB_ERR_NONE;
 }
From dfa966dcac4ff53e83f68be4643d33db6c9d98ef Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 11 Aug 2016 15:02:21 -0700
Subject: [PATCH] gpt: refuse to write to sector 0

---
 grub-core/lib/gpt.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index f83fe29ac..b7449911a 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -626,10 +626,17 @@ grub_gpt_write_table (grub_disk_t disk, grub_gpt_t gpt,
 		       sizeof (*header));
 
   addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->header_lba));
+  if (addr == 0)
+    return grub_error (GRUB_ERR_BUG,
+		       "Refusing to write GPT header to address 0x0");
   if (grub_disk_write (disk, addr, 0, sizeof (*header), header))
     return grub_errno;
 
   addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->partitions));
+  if (addr < 2)
+    return grub_error (GRUB_ERR_BUG,
+		       "Refusing to write GPT entries to address 0x%llx",
+		       (unsigned long long) addr);
   if (grub_disk_write (disk, addr, 0, gpt->entries_size, gpt->entries))
     return grub_errno;
 
From ac69188a7031e0255012900519f406baea7d9278 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Sat, 20 Aug 2016 17:42:12 -0700
Subject: [PATCH] gpt: properly detect and repair invalid tables

GPT_BOTH_VALID is 4 bits so simple a boolean check is not sufficient.
This broken condition allowed gptprio to trust bogus disk locations in
headers that were marked invalid causing arbitrary disk corruption.
---
 grub-core/commands/gptprio.c | 2 +-
 grub-core/lib/gpt.c          | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
index ce5840b4e..6b61bb56d 100644
--- a/grub-core/commands/gptprio.c
+++ b/grub-core/commands/gptprio.c
@@ -91,7 +91,7 @@ grub_find_next (const char *disk_name,
   if (!gpt)
     goto done;
 
-  if (!(gpt->status & GRUB_GPT_BOTH_VALID))
+  if ((gpt->status & GRUB_GPT_BOTH_VALID) != GRUB_GPT_BOTH_VALID)
     if (grub_gpt_repair (dev->disk, gpt))
       goto done;
 
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index b7449911a..0daf3f8de 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -648,7 +648,7 @@ grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt)
 {
   /* TODO: update/repair protective MBRs too.  */
 
-  if (!(gpt->status & GRUB_GPT_BOTH_VALID))
+  if ((gpt->status & GRUB_GPT_BOTH_VALID) != GRUB_GPT_BOTH_VALID)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "Invalid GPT data");
 
   grub_dprintf ("gpt", "writing primary GPT to %s\n", disk->name);
From 2ec96d73aec713dc3f8b45f27fae4008fb9bb516 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Mon, 22 Aug 2016 16:44:30 -0700
Subject: [PATCH] gptrepair_test: fix typo in cleanup trap

---
 tests/gptrepair_test.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tests/gptrepair_test.in b/tests/gptrepair_test.in
index 80b2de633..805dc171a 100644
--- a/tests/gptrepair_test.in
+++ b/tests/gptrepair_test.in
@@ -53,7 +53,7 @@ case "${grub_modinfo_target_cpu}-${grub_modinfo_platform}" in
 esac
 img1="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
 img2="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
-trap "rm -f '${img1}' '${ing2}'" EXIT
+trap "rm -f '${img1}' '${img2}'" EXIT
 
 create_disk_image () {
     size=$1
From 384c0976b3bb8fca413bd3b0af22604104824511 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Mon, 22 Aug 2016 16:45:10 -0700
Subject: [PATCH] gptprio_test: check GPT is repaired when appropriate

---
 tests/gptprio_test.in | 63 ++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 60 insertions(+), 3 deletions(-)

diff --git a/tests/gptprio_test.in b/tests/gptprio_test.in
index f4aea0dc9..c5cf0f3b7 100644
--- a/tests/gptprio_test.in
+++ b/tests/gptprio_test.in
@@ -66,8 +66,9 @@ prio_uuid[3]="1aa5a658-5b02-414d-9b71-f7e6c151f0cd"
 prio_uuid[4]="8aa0240d-98af-42b0-b32a-ccbe0572d62b"
 
 create_disk_image () {
+    size=$1
     rm -f "${img1}"
-    dd if=/dev/zero of="${img1}" bs=512 count=1 seek=100 status=none
+    dd if=/dev/zero of="${img1}" bs=512 count=1 seek=$((size - 1)) status=none
     ${sgdisk} \
         -n 1:0:+1 -c 1:ESP -t 1:ef00 \
         -n 2:0:+1 -c 2:A -t 2:"${prio_type}" -u 2:"${prio_uuid[2]}" \
@@ -76,6 +77,35 @@ create_disk_image () {
         "${img1}" >/dev/null
 }
 
+wipe_disk_area () {
+    sector=$1
+    size=$2
+    dd if=/dev/zero of="${img1}" bs=512 count=${size} seek=${sector} conv=notrunc status=none
+}
+
+is_zero () {
+    sector=$1
+    size=$2
+    cmp -s -i $((sector * 512)) -n $((size * 512)) /dev/zero "${img1}"
+}
+
+check_is_zero () {
+    sector=$1
+    size=$2
+    if ! is_zero "$@"; then
+        echo "$size sector(s) starting at $sector should be all zero"
+        exit 1
+    fi
+}
+
+check_not_zero () {
+    sector=$1
+    size=$2
+    if is_zero "$@"; then
+        echo "$size sector(s) starting at $sector should not be all zero"
+        exit 1
+    fi
+}
 
 fmt_prio () {
     priority=$(( ( $1 & 15 ) << 48 ))
@@ -93,10 +123,10 @@ set_prio () {
 check_prio () {
     part="$1"
     expect=$(fmt_prio $2 $3 $4)
-    result=$(LANG=C ${sgdisk} -i "${part}" "${img1}" \
+    result=$(LANG=C ${sgdisk} -i "${part}" "${img1}" 2>&1 \
             | awk '/^Attribute flags: / {print $3}')
     if [[ "${expect}" != "${result}" ]]; then
-        echo "Partition ${part} has attributes ${result}, not ${expect}" >&2
+        echo "Partition ${part} has attributes ${result:-??}, not ${expect}"
         exit 1
     fi
 }
@@ -133,6 +163,33 @@ create_disk_image 100
 set_prio 2 3 2 1
 check_prio 2 3 2 1
 
+# Check gptprio works without modifying the disk when no update is required.
+# Leaves any existing corruption as is, repairing in the OS is better.
+create_disk_image 100
+set_prio 2 1 0 1
+wipe_disk_area 99 1
+check_next 2 1 0 1
+check_is_zero 99 1
+
+create_disk_image 100
+set_prio 2 1 0 1
+wipe_disk_area 1 1
+check_next 2 1 0 1
+check_is_zero 1 1
+
+# When writes do need to be made go ahead and perform the repair.
+create_disk_image 100
+set_prio 2 1 1 0
+wipe_disk_area 99 1
+check_next 2 1 0 0
+check_not_zero 99 1
+
+create_disk_image 100
+set_prio 2 1 1 0
+wipe_disk_area 1 1
+check_next 2 1 0 0
+check_not_zero 1 1
+
 # Try two partitions before falling before falling back to a third
 create_disk_image 100
 set_prio 2 3 3 0
From 96d36c4ecdb8b3dfe0ecd81dff3c1cd6665e73c3 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 24 Aug 2016 16:14:20 -0700
Subject: [PATCH] gpt: fix partition table indexing and validation

Portions of the code attempted to handle the fact that GPT entries on
disk may be larger than the currently defined struct while others
assumed the data could be indexed by the struct size directly. This
never came up because no utility uses a size larger than 128 bytes but
for the sake of safety we need to do this by the spec.
---
 grub-core/commands/gptprio.c |   6 +--
 grub-core/lib/gpt.c          |  51 +++++++++++++++---
 include/grub/gpt_partition.h |  11 +++-
 tests/gpt_unit_test.c        | 120 +++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 176 insertions(+), 12 deletions(-)

diff --git a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
index 6b61bb56d..548925a08 100644
--- a/grub-core/commands/gptprio.c
+++ b/grub-core/commands/gptprio.c
@@ -78,7 +78,7 @@ grub_find_next (const char *disk_name,
 		const grub_gpt_part_type_t *part_type,
 		char **part_name, char **part_guid)
 {
-  struct grub_gpt_partentry *part_found = NULL;
+  struct grub_gpt_partentry *part, *part_found = NULL;
   grub_device_t dev = NULL;
   grub_gpt_t gpt = NULL;
   grub_uint32_t i, part_index;
@@ -95,10 +95,8 @@ grub_find_next (const char *disk_name,
     if (grub_gpt_repair (dev->disk, gpt))
       goto done;
 
-  for (i = 0; i < grub_le_to_cpu32 (gpt->primary.maxpart); i++)
+  for (i = 0; (part = grub_gpt_get_partentry (gpt, i)) != NULL; i++)
     {
-      struct grub_gpt_partentry *part = &gpt->entries[i];
-
       if (grub_memcmp (part_type, &part->type, sizeof (*part_type)) == 0)
 	{
 	  unsigned int priority, tries_left, successful, old_priority = 0;
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 0daf3f8de..205779192 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -207,6 +207,13 @@ grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr)
   return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid protective MBR");
 }
 
+static grub_uint64_t
+grub_gpt_entries_size (struct grub_gpt_header *gpt)
+{
+  return (grub_uint64_t) grub_le_to_cpu32 (gpt->maxpart) *
+         (grub_uint64_t) grub_le_to_cpu32 (gpt->partentry_size);
+}
+
 static grub_uint64_t
 grub_gpt_entries_sectors (struct grub_gpt_header *gpt,
 			  unsigned int log_sector_size)
@@ -214,11 +221,16 @@ grub_gpt_entries_sectors (struct grub_gpt_header *gpt,
   grub_uint64_t sector_bytes, entries_bytes;
 
   sector_bytes = 1ULL << log_sector_size;
-  entries_bytes = (grub_uint64_t) grub_le_to_cpu32 (gpt->maxpart) *
-		  (grub_uint64_t) grub_le_to_cpu32 (gpt->partentry_size);
+  entries_bytes = grub_gpt_entries_size (gpt);
   return grub_divmod64(entries_bytes + sector_bytes - 1, sector_bytes, NULL);
 }
 
+static int
+is_pow2 (grub_uint32_t n)
+{
+  return (n & (n - 1)) == 0;
+}
+
 grub_err_t
 grub_gpt_header_check (struct grub_gpt_header *gpt,
 		       unsigned int log_sector_size)
@@ -236,16 +248,23 @@ grub_gpt_header_check (struct grub_gpt_header *gpt,
   if (gpt->crc32 != crc)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header crc32");
 
-  /* The header size must be between 92 and the sector size.  */
+  /* The header size "must be greater than or equal to 92 and must be less
+   * than or equal to the logical block size."  */
   size = grub_le_to_cpu32 (gpt->headersize);
   if (size < 92U || size > (1U << log_sector_size))
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header size");
 
-  /* The partition entry size must be a multiple of 128.  */
+  /* The partition entry size must be "a value of 128*(2^n) where n is an
+   * integer greater than or equal to zero (e.g., 128, 256, 512, etc.)."  */
   size = grub_le_to_cpu32 (gpt->partentry_size);
-  if (size < 128 || size % 128)
+  if (size < 128U || size % 128U || !is_pow2 (size / 128U))
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry size");
 
+  /* The minimum entries table size is specified in terms of bytes,
+   * regardless of how large the individual entry size is.  */
+  if (grub_gpt_entries_size (gpt) < GRUB_GPT_DEFAULT_ENTRIES_SIZE)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry table size");
+
   /* And of course there better be some space for partitions!  */
   start = grub_le_to_cpu64 (gpt->start);
   end = grub_le_to_cpu64 (gpt->end);
@@ -410,7 +429,7 @@ static grub_err_t
 grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
 		       struct grub_gpt_header *header)
 {
-  struct grub_gpt_partentry *entries = NULL;
+  void *entries = NULL;
   grub_uint32_t count, size, crc;
   grub_uint64_t sector;
   grub_disk_addr_t addr;
@@ -526,6 +545,26 @@ fail:
   return NULL;
 }
 
+struct grub_gpt_partentry *
+grub_gpt_get_partentry (grub_gpt_t gpt, grub_uint32_t n)
+{
+  struct grub_gpt_header *header;
+  grub_size_t offset;
+
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    header = &gpt->primary;
+  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    header = &gpt->backup;
+  else
+    return NULL;
+
+  if (n >= grub_le_to_cpu32 (header->maxpart))
+    return NULL;
+
+  offset = (grub_size_t) grub_le_to_cpu32 (header->partentry_size) * n;
+  return (struct grub_gpt_partentry *) ((char *) gpt->entries + offset);
+}
+
 grub_err_t
 grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 {
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 4a6ed25b3..cc3a201a5 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -186,8 +186,10 @@ struct grub_gpt
   struct grub_gpt_header primary;
   struct grub_gpt_header backup;
 
-  /* Only need one entries table, on disk both copies are identical.  */
-  struct grub_gpt_partentry *entries;
+  /* Only need one entries table, on disk both copies are identical.
+   * The on disk entry size may be larger than our partentry struct so
+   * the table cannot be indexed directly.  */
+  void *entries;
   grub_size_t entries_size;
 
   /* Logarithm of sector size, in case GPT and disk driver disagree.  */
@@ -205,6 +207,11 @@ grub_gpt_sector_to_addr (grub_gpt_t gpt, grub_uint64_t sector)
 /* Allocates and fills new grub_gpt structure, free with grub_gpt_free.  */
 grub_gpt_t grub_gpt_read (grub_disk_t disk);
 
+/* Helper for indexing into the entries table.
+ * Returns NULL when the end of the table has been reached.  */
+struct grub_gpt_partentry * grub_gpt_get_partentry (grub_gpt_t gpt,
+						    grub_uint32_t n);
+
 /* Sync up primary and backup headers, recompute checksums.  */
 grub_err_t grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt);
 
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index 60f601729..9cf3414c2 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -40,6 +40,13 @@
 /* from gnulib */
 #include <verify.h>
 
+/* Confirm that the GPT structures conform to the sizes in the spec:
+ * The header size "must be greater than or equal to 92 and must be less
+ * than or equal to the logical block size."
+ * The partition entry size must be "a value of 128*(2^n) where n is an
+ * integer greater than or equal to zero (e.g., 128, 256, 512, etc.)."  */
+verify (sizeof (struct grub_gpt_header) == 92);
+verify (sizeof (struct grub_gpt_partentry) == 128);
 
 /* GPT section sizes.  */
 #define HEADER_SIZE   (sizeof (struct grub_gpt_header))
@@ -537,6 +544,113 @@ repair_test (void)
   close_disk (&data);
 }
 
+static void
+iterate_partitions_test (void)
+{
+  struct test_data data;
+  struct grub_gpt_partentry *p;
+  grub_gpt_t gpt;
+  grub_uint32_t n;
+
+  open_disk (&data);
+  gpt = read_disk (&data);
+
+  for (n = 0; (p = grub_gpt_get_partentry (gpt, n)) != NULL; n++)
+    grub_test_assert (memcmp (p, &example_entries[n], sizeof (*p)) == 0,
+		      "unexpected partition %d data", n);
+
+  grub_test_assert (n == TABLE_ENTRIES, "unexpected partition limit: %d", n);
+
+  grub_gpt_free (gpt);
+  close_disk (&data);
+}
+
+static void
+large_partitions_test (void)
+{
+  struct test_data data;
+  struct grub_gpt_partentry *p;
+  grub_gpt_t gpt;
+  grub_uint32_t n;
+
+  open_disk (&data);
+
+  /* Double the entry size, cut the number of entries in half.  */
+  data.raw->primary_header.maxpart =
+    data.raw->backup_header.maxpart =
+    grub_cpu_to_le32_compile_time (TABLE_ENTRIES/2);
+  data.raw->primary_header.partentry_size =
+    data.raw->backup_header.partentry_size =
+    grub_cpu_to_le32_compile_time (ENTRY_SIZE*2);
+  data.raw->primary_header.partentry_crc32 =
+    data.raw->backup_header.partentry_crc32 =
+    grub_cpu_to_le32_compile_time (0xf2c45af8);
+  data.raw->primary_header.crc32 = grub_cpu_to_le32_compile_time (0xde00cc8f);
+  data.raw->backup_header.crc32 = grub_cpu_to_le32_compile_time (0x6d72e284);
+
+  memset (&data.raw->primary_entries, 0,
+	  sizeof (data.raw->primary_entries));
+  for (n = 0; n < TABLE_ENTRIES/2; n++)
+    memcpy (&data.raw->primary_entries[n*2], &example_entries[n],
+	    sizeof (data.raw->primary_entries[0]));
+  memcpy (&data.raw->backup_entries, &data.raw->primary_entries,
+	  sizeof (data.raw->backup_entries));
+
+  sync_disk(&data);
+  gpt = read_disk (&data);
+
+  for (n = 0; (p = grub_gpt_get_partentry (gpt, n)) != NULL; n++)
+    grub_test_assert (memcmp (p, &example_entries[n], sizeof (*p)) == 0,
+		      "unexpected partition %d data", n);
+
+  grub_test_assert (n == TABLE_ENTRIES/2, "unexpected partition limit: %d", n);
+
+  grub_gpt_free (gpt);
+
+  /* Editing memory beyond the entry structure should still change the crc.  */
+  data.raw->primary_entries[1].attrib = 0xff;
+
+  sync_disk(&data);
+  gpt = read_disk (&data);
+  grub_test_assert (gpt->status == (GRUB_GPT_PROTECTIVE_MBR |
+				    GRUB_GPT_PRIMARY_HEADER_VALID |
+				    GRUB_GPT_BACKUP_HEADER_VALID |
+				    GRUB_GPT_BACKUP_ENTRIES_VALID),
+		    "unexpected status: 0x%02x", gpt->status);
+  grub_gpt_free (gpt);
+
+  close_disk (&data);
+}
+
+static void
+invalid_partsize_test (void)
+{
+  struct grub_gpt_header header = {
+    .magic = GRUB_GPT_HEADER_MAGIC,
+    .version = GRUB_GPT_HEADER_VERSION,
+    .headersize = sizeof (struct grub_gpt_header),
+    .crc32 = grub_cpu_to_le32_compile_time (0x1ff2a054),
+    .header_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+    .alternate_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+    .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+    .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
+    .guid = GRUB_GPT_GUID_INIT(0x69c131ad, 0x67d6, 0x46c6,
+			       0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac),
+    .partitions = grub_cpu_to_le64_compile_time (PRIMARY_TABLE_SECTOR),
+    .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
+    /* Triple the entry size, which is not valid.  */
+    .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE*3),
+    .partentry_crc32 = grub_cpu_to_le32_compile_time (0x074e052c),
+  };
+
+  grub_gpt_header_check(&header, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_test_assert (strcmp(grub_errmsg, "invalid GPT entry size") == 0,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+}
+
 static void
 search_part_label_test (void)
 {
@@ -657,6 +771,9 @@ grub_unit_test_init (void)
   grub_test_register ("gpt_read_invalid_test", read_invalid_entries_test);
   grub_test_register ("gpt_read_fallback_test", read_fallback_test);
   grub_test_register ("gpt_repair_test", repair_test);
+  grub_test_register ("gpt_iterate_partitions_test", iterate_partitions_test);
+  grub_test_register ("gpt_large_partitions_test", large_partitions_test);
+  grub_test_register ("gpt_invalid_partsize_test", invalid_partsize_test);
   grub_test_register ("gpt_search_part_label_test", search_part_label_test);
   grub_test_register ("gpt_search_uuid_test", search_part_uuid_test);
   grub_test_register ("gpt_search_disk_uuid_test", search_disk_uuid_test);
@@ -671,6 +788,9 @@ grub_unit_test_fini (void)
   grub_test_unregister ("gpt_read_invalid_test");
   grub_test_unregister ("gpt_read_fallback_test");
   grub_test_unregister ("gpt_repair_test");
+  grub_test_unregister ("gpt_iterate_partitions_test");
+  grub_test_unregister ("gpt_large_partitions_test");
+  grub_test_unregister ("gpt_invalid_partsize_test");
   grub_test_unregister ("gpt_search_part_label_test");
   grub_test_unregister ("gpt_search_part_uuid_test");
   grub_test_unregister ("gpt_search_disk_uuid_test");
From 3ef7f041f419f8c62f6d7b5c60dc1da45862c074 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Tue, 23 Aug 2016 13:09:14 -0700
Subject: [PATCH] gpt: prefer disk size from header over firmware

The firmware and the OS may disagree on the disk configuration and size.
Although such a setup should be avoided users are unlikely to know about
the problem, assuming everything behaves like the OS. Tolerate this as
best we can and trust the reported on-disk location over the firmware
when looking for the backup GPT. If the location is inaccessible report
the error as best we can and move on.
---
 grub-core/lib/gpt.c   | 18 +++++++++++++-----
 tests/gpt_unit_test.c | 42 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+), 5 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 205779192..f0c71bde1 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -394,13 +394,21 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
   grub_disk_addr_t addr;
 
   /* Assumes gpt->log_sector_size == disk->log_sector_size  */
-  if (grub_gpt_disk_size_valid(disk))
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    {
+      sector = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+      if (grub_gpt_disk_size_valid (disk) && sector >= disk->total_sectors)
+	return grub_error (GRUB_ERR_OUT_OF_RANGE,
+			   "backup GPT located at 0x%llx, "
+			   "beyond last disk sector at 0x%llx",
+			   (unsigned long long) sector,
+			   (unsigned long long) disk->total_sectors - 1);
+    }
+  else if (grub_gpt_disk_size_valid (disk))
     sector = disk->total_sectors - 1;
-  else if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
-    sector = grub_le_to_cpu64 (gpt->primary.alternate_lba);
   else
-    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
-		       "Unable to locate backup GPT");
+    return grub_error (GRUB_ERR_OUT_OF_RANGE,
+		       "size of disk unknown, cannot locate backup GPT");
 
   grub_dprintf ("gpt", "reading backup GPT from sector 0x%llx\n",
 		(unsigned long long) sector);
diff --git a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
index 9cf3414c2..218b18697 100644
--- a/tests/gpt_unit_test.c
+++ b/tests/gpt_unit_test.c
@@ -544,6 +544,46 @@ repair_test (void)
   close_disk (&data);
 }
 
+/* Finding/reading/writing the backup GPT may be difficult if the OS and
+ * BIOS report different sizes for the same disk.  We need to gracefully
+ * recognize this and avoid causing trouble for the OS.  */
+static void
+weird_disk_size_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Chop off 65536 bytes (128 512B sectors) which may happen when the
+   * BIOS thinks you are using a software RAID system that reserves that
+   * area for metadata when in fact you are not and using the bare disk.  */
+  grub_test_assert(data.dev->disk->total_sectors == DISK_SECTORS,
+		   "unexpected disk size: 0x%llx",
+		   (unsigned long long) data.dev->disk->total_sectors);
+  data.dev->disk->total_sectors -= 128;
+
+  gpt = read_disk (&data);
+  assert_error_stack_empty ();
+  /* Reading the alternate_lba should have been blocked and reading
+   * the (new) end of disk should have found no useful data.  */
+  grub_test_assert ((gpt->status & GRUB_GPT_BACKUP_HEADER_VALID) == 0,
+		    "unreported missing backup header");
+
+  /* We should be able to reconstruct the backup header and the location
+   * of the backup should remain unchanged, trusting the GPT data over
+   * what the BIOS is telling us.  Further changes are left to the OS.  */
+  grub_gpt_repair (data.dev->disk, gpt);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "repair failed: %s", grub_errmsg);
+  grub_test_assert (memcmp (&gpt->primary, &example_primary,
+	                    sizeof (gpt->primary)) == 0,
+		    "repair corrupted primary header");
+
+  grub_gpt_free (gpt);
+  close_disk (&data);
+}
+
 static void
 iterate_partitions_test (void)
 {
@@ -774,6 +814,7 @@ grub_unit_test_init (void)
   grub_test_register ("gpt_iterate_partitions_test", iterate_partitions_test);
   grub_test_register ("gpt_large_partitions_test", large_partitions_test);
   grub_test_register ("gpt_invalid_partsize_test", invalid_partsize_test);
+  grub_test_register ("gpt_weird_disk_size_test", weird_disk_size_test);
   grub_test_register ("gpt_search_part_label_test", search_part_label_test);
   grub_test_register ("gpt_search_uuid_test", search_part_uuid_test);
   grub_test_register ("gpt_search_disk_uuid_test", search_disk_uuid_test);
@@ -791,6 +832,7 @@ grub_unit_test_fini (void)
   grub_test_unregister ("gpt_iterate_partitions_test");
   grub_test_unregister ("gpt_large_partitions_test");
   grub_test_unregister ("gpt_invalid_partsize_test");
+  grub_test_unregister ("gpt_weird_disk_size_test");
   grub_test_unregister ("gpt_search_part_label_test");
   grub_test_unregister ("gpt_search_part_uuid_test");
   grub_test_unregister ("gpt_search_disk_uuid_test");
From d1a329f0d8b5f272b925dd1e54c7e1e93ec555ca Mon Sep 17 00:00:00 2001
From: Vito Caputo <vito.caputo@coreos.com>
Date: Thu, 25 Aug 2016 17:21:18 -0700
Subject: [PATCH] gpt: add helper for picking a valid header

Eliminate some repetition in primary vs. backup header acquisition.
---
 grub-core/lib/gpt.c | 32 ++++++++++++++++++++------------
 1 file changed, 20 insertions(+), 12 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index f0c71bde1..2550ed87c 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -108,21 +108,32 @@ grub_gpt_part_uuid (grub_device_t device, char **uuid)
   return GRUB_ERR_NONE;
 }
 
+static struct grub_gpt_header *
+grub_gpt_get_header (grub_gpt_t gpt)
+{
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    return &gpt->primary;
+  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    return &gpt->backup;
+
+  grub_error (GRUB_ERR_BUG, "No valid GPT header");
+  return NULL;
+}
+
 grub_err_t
 grub_gpt_disk_uuid (grub_device_t device, char **uuid)
 {
+  struct grub_gpt_header *header;
+
   grub_gpt_t gpt = grub_gpt_read (device->disk);
   if (!gpt)
     goto done;
 
-  grub_errno = GRUB_ERR_NONE;
+  header = grub_gpt_get_header (gpt);
+  if (!header)
+    goto done;
 
-  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
-    *uuid = grub_gpt_guid_to_str (&gpt->primary.guid);
-  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
-    *uuid = grub_gpt_guid_to_str (&gpt->backup.guid);
-  else
-    grub_errno = grub_error (GRUB_ERR_BUG, "No valid GPT header");
+  *uuid = grub_gpt_guid_to_str (&header->guid);
 
 done:
   grub_gpt_free (gpt);
@@ -559,11 +570,8 @@ grub_gpt_get_partentry (grub_gpt_t gpt, grub_uint32_t n)
   struct grub_gpt_header *header;
   grub_size_t offset;
 
-  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
-    header = &gpt->primary;
-  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
-    header = &gpt->backup;
-  else
+  header = grub_gpt_get_header (gpt);
+  if (!header)
     return NULL;
 
   if (n >= grub_le_to_cpu32 (header->maxpart))
From e2074ff46920d5332cbc3209160b7987da76080b Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Tue, 20 Sep 2016 13:06:05 -0700
Subject: [PATCH] gptrepair: fix status checking

None of these status bit checks were correct. Fix and simplify.
---
 grub-core/commands/gptrepair.c | 28 +++++++++++-----------------
 1 file changed, 11 insertions(+), 17 deletions(-)

diff --git a/grub-core/commands/gptrepair.c b/grub-core/commands/gptrepair.c
index 38392fd8f..66ac3f7c7 100644
--- a/grub-core/commands/gptrepair.c
+++ b/grub-core/commands/gptrepair.c
@@ -46,8 +46,6 @@ grub_cmd_gptrepair (grub_command_t cmd __attribute__ ((unused)),
   grub_device_t dev = NULL;
   grub_gpt_t gpt = NULL;
   char *dev_name;
-  grub_uint32_t primary_crc, backup_crc;
-  enum grub_gpt_status old_status;
 
   if (argc != 1 || !grub_strlen(args[0]))
     return grub_error (GRUB_ERR_BAD_ARGUMENT, "device name required");
@@ -67,29 +65,25 @@ grub_cmd_gptrepair (grub_command_t cmd __attribute__ ((unused)),
   if (!gpt)
     goto done;
 
-  primary_crc = gpt->primary.crc32;
-  backup_crc = gpt->backup.crc32;
-  old_status = gpt->status;
-
-  if (grub_gpt_repair (dev->disk, gpt))
-    goto done;
-
-  if (primary_crc == gpt->primary.crc32 &&
-      backup_crc == gpt->backup.crc32 &&
-      old_status && gpt->status)
+  if ((gpt->status & GRUB_GPT_BOTH_VALID) == GRUB_GPT_BOTH_VALID)
     {
       grub_printf_ (N_("GPT already valid, %s unmodified.\n"), dev_name);
       goto done;
     }
 
-  if (grub_gpt_write (dev->disk, gpt))
+  if ((gpt->status & GRUB_GPT_PRIMARY_VALID) != GRUB_GPT_PRIMARY_VALID)
+    grub_printf_ (N_("Found invalid primary GPT on %s\n"), dev_name);
+
+  if ((gpt->status & GRUB_GPT_BACKUP_VALID) != GRUB_GPT_BACKUP_VALID)
+    grub_printf_ (N_("Found invalid backup GPT on %s\n"), dev_name);
+
+  if (grub_gpt_repair (dev->disk, gpt))
     goto done;
 
-  if (!(old_status & GRUB_GPT_PRIMARY_VALID))
-    grub_printf_ (N_("Primary GPT for %s repaired.\n"), dev_name);
+  if (grub_gpt_write (dev->disk, gpt))
+    goto done;
 
-  if (!(old_status & GRUB_GPT_BACKUP_VALID))
-    grub_printf_ (N_("Backup GPT for %s repaired.\n"), dev_name);
+  grub_printf_ (N_("Repaired GPT on %s\n"), dev_name);
 
 done:
   if (gpt)
From f51e80579fd2b69d64dd98c0a8be44eb65556363 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Tue, 20 Sep 2016 12:43:01 -0700
Subject: [PATCH] gpt: use inline functions for checking status bits

This should prevent bugs like 6078f836 and 4268f3da.
---
 grub-core/commands/gptprio.c   |  2 +-
 grub-core/commands/gptrepair.c |  6 +++---
 grub-core/lib/gpt.c            |  9 +++++++--
 include/grub/gpt_partition.h   | 35 ++++++++++++++++++++++++++++-------
 4 files changed, 39 insertions(+), 13 deletions(-)

diff --git a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
index 548925a08..25f867a81 100644
--- a/grub-core/commands/gptprio.c
+++ b/grub-core/commands/gptprio.c
@@ -91,7 +91,7 @@ grub_find_next (const char *disk_name,
   if (!gpt)
     goto done;
 
-  if ((gpt->status & GRUB_GPT_BOTH_VALID) != GRUB_GPT_BOTH_VALID)
+  if (!grub_gpt_both_valid(gpt))
     if (grub_gpt_repair (dev->disk, gpt))
       goto done;
 
diff --git a/grub-core/commands/gptrepair.c b/grub-core/commands/gptrepair.c
index 66ac3f7c7..c17c7346c 100644
--- a/grub-core/commands/gptrepair.c
+++ b/grub-core/commands/gptrepair.c
@@ -65,16 +65,16 @@ grub_cmd_gptrepair (grub_command_t cmd __attribute__ ((unused)),
   if (!gpt)
     goto done;
 
-  if ((gpt->status & GRUB_GPT_BOTH_VALID) == GRUB_GPT_BOTH_VALID)
+  if (grub_gpt_both_valid (gpt))
     {
       grub_printf_ (N_("GPT already valid, %s unmodified.\n"), dev_name);
       goto done;
     }
 
-  if ((gpt->status & GRUB_GPT_PRIMARY_VALID) != GRUB_GPT_PRIMARY_VALID)
+  if (!grub_gpt_primary_valid (gpt))
     grub_printf_ (N_("Found invalid primary GPT on %s\n"), dev_name);
 
-  if ((gpt->status & GRUB_GPT_BACKUP_VALID) != GRUB_GPT_BACKUP_VALID)
+  if (!grub_gpt_backup_valid (gpt))
     grub_printf_ (N_("Found invalid backup GPT on %s\n"), dev_name);
 
   if (grub_gpt_repair (dev->disk, gpt))
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 2550ed87c..3e077c497 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -638,10 +638,15 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   if (grub_gpt_check_primary (gpt))
     return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
 
+  gpt->status |= (GRUB_GPT_PRIMARY_HEADER_VALID |
+		  GRUB_GPT_PRIMARY_ENTRIES_VALID);
+
   if (grub_gpt_check_backup (gpt))
     return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
 
-  gpt->status |= GRUB_GPT_BOTH_VALID;
+  gpt->status |= (GRUB_GPT_BACKUP_HEADER_VALID |
+		  GRUB_GPT_BACKUP_ENTRIES_VALID);
+
   grub_dprintf ("gpt", "repairing GPT for %s successful\n", disk->name);
 
   return GRUB_ERR_NONE;
@@ -703,7 +708,7 @@ grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt)
 {
   /* TODO: update/repair protective MBRs too.  */
 
-  if ((gpt->status & GRUB_GPT_BOTH_VALID) != GRUB_GPT_BOTH_VALID)
+  if (!grub_gpt_both_valid (gpt))
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "Invalid GPT data");
 
   grub_dprintf ("gpt", "writing primary GPT to %s\n", disk->name);
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index cc3a201a5..39388ce6e 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -161,13 +161,6 @@ typedef enum grub_gpt_status
     GRUB_GPT_BACKUP_ENTRIES_VALID   = 0x20,
   } grub_gpt_status_t;
 
-#define GRUB_GPT_MBR_VALID (GRUB_GPT_PROTECTIVE_MBR|GRUB_GPT_HYBRID_MBR)
-#define GRUB_GPT_PRIMARY_VALID \
-  (GRUB_GPT_PRIMARY_HEADER_VALID|GRUB_GPT_PRIMARY_ENTRIES_VALID)
-#define GRUB_GPT_BACKUP_VALID \
-  (GRUB_GPT_BACKUP_HEADER_VALID|GRUB_GPT_BACKUP_ENTRIES_VALID)
-#define GRUB_GPT_BOTH_VALID (GRUB_GPT_PRIMARY_VALID|GRUB_GPT_BACKUP_VALID)
-
 /* UEFI requires the entries table to be at least 16384 bytes for a
  * total of 128 entries given the standard 128 byte entry size.  */
 #define GRUB_GPT_DEFAULT_ENTRIES_SIZE	16384
@@ -197,6 +190,34 @@ struct grub_gpt
 };
 typedef struct grub_gpt *grub_gpt_t;
 
+/* Helpers for checking the gpt status field.  */
+static inline int
+grub_gpt_mbr_valid (grub_gpt_t gpt)
+{
+  return ((gpt->status & GRUB_GPT_PROTECTIVE_MBR) ||
+	  (gpt->status & GRUB_GPT_HYBRID_MBR));
+}
+
+static inline int
+grub_gpt_primary_valid (grub_gpt_t gpt)
+{
+  return ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) &&
+	  (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID));
+}
+
+static inline int
+grub_gpt_backup_valid (grub_gpt_t gpt)
+{
+  return ((gpt->status & GRUB_GPT_BACKUP_HEADER_VALID) &&
+	  (gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID));
+}
+
+static inline int
+grub_gpt_both_valid (grub_gpt_t gpt)
+{
+  return grub_gpt_primary_valid (gpt) && grub_gpt_backup_valid (gpt);
+}
+
 /* Translate GPT sectors to GRUB's 512 byte block addresses.  */
 static inline grub_disk_addr_t
 grub_gpt_sector_to_addr (grub_gpt_t gpt, grub_uint64_t sector)
From 025c41dafe285a36dae7ff1b4217520d7839bdb4 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Tue, 20 Sep 2016 13:40:11 -0700
Subject: [PATCH] gpt: allow repair function to noop

Simplifies usage a little.
---
 grub-core/commands/gptprio.c | 5 ++---
 grub-core/lib/gpt.c          | 4 ++++
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
index 25f867a81..a439552e1 100644
--- a/grub-core/commands/gptprio.c
+++ b/grub-core/commands/gptprio.c
@@ -91,9 +91,8 @@ grub_find_next (const char *disk_name,
   if (!gpt)
     goto done;
 
-  if (!grub_gpt_both_valid(gpt))
-    if (grub_gpt_repair (dev->disk, gpt))
-      goto done;
+  if (grub_gpt_repair (dev->disk, gpt))
+    goto done;
 
   for (i = 0; (part = grub_gpt_get_partentry (gpt, i)) != NULL; i++)
     {
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 3e077c497..9bb19678d 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -586,6 +586,10 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 {
   grub_uint64_t backup_header, backup_entries;
 
+  /* Skip if there is nothing to do.  */
+  if (grub_gpt_both_valid (gpt))
+    return GRUB_ERR_NONE;
+
   grub_dprintf ("gpt", "repairing GPT for %s\n", disk->name);
 
   if (disk->log_sector_size != gpt->log_sector_size)
From d52abba6dabec22edfa420eddf60c8f4d41b7f32 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 13:22:06 -0700
Subject: [PATCH] gpt: do not use an enum for status bit values

---
 include/grub/gpt_partition.h | 19 +++++++++----------
 1 file changed, 9 insertions(+), 10 deletions(-)

diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 39388ce6e..ee435d73b 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -151,15 +151,14 @@ grub_gpt_partition_map_iterate (grub_disk_t disk,
 				void *hook_data);
 
 /* Advanced GPT library.  */
-typedef enum grub_gpt_status
-  {
-    GRUB_GPT_PROTECTIVE_MBR         = 0x01,
-    GRUB_GPT_HYBRID_MBR             = 0x02,
-    GRUB_GPT_PRIMARY_HEADER_VALID   = 0x04,
-    GRUB_GPT_PRIMARY_ENTRIES_VALID  = 0x08,
-    GRUB_GPT_BACKUP_HEADER_VALID    = 0x10,
-    GRUB_GPT_BACKUP_ENTRIES_VALID   = 0x20,
-  } grub_gpt_status_t;
+
+/* Status bits for the grub_gpt.status field.  */
+#define GRUB_GPT_PROTECTIVE_MBR		0x01
+#define GRUB_GPT_HYBRID_MBR		0x02
+#define GRUB_GPT_PRIMARY_HEADER_VALID	0x04
+#define GRUB_GPT_PRIMARY_ENTRIES_VALID	0x08
+#define GRUB_GPT_BACKUP_HEADER_VALID	0x10
+#define GRUB_GPT_BACKUP_ENTRIES_VALID	0x20
 
 /* UEFI requires the entries table to be at least 16384 bytes for a
  * total of 128 entries given the standard 128 byte entry size.  */
@@ -170,7 +169,7 @@ typedef enum grub_gpt_status
 struct grub_gpt
 {
   /* Bit field indicating which structures on disk are valid.  */
-  grub_gpt_status_t status;
+  unsigned status;
 
   /* Protective or hybrid MBR.  */
   struct grub_msdos_partition_mbr mbr;
From 294ebeeff46ab1a778ca070e64cab7eb3e8a6581 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 13:44:11 -0700
Subject: [PATCH] gpt: check header and entries status bits together

Use the new status function which checks *_HEADER_VALID and
*_ENTRIES_VALID bits together. It doesn't make sense for the header and
entries bits to mismatch so don't allow for it.
---
 grub-core/lib/gpt.c | 14 +++++---------
 1 file changed, 5 insertions(+), 9 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 9bb19678d..3c6ff3540 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -596,24 +596,20 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
     return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 		       "GPT sector size must match disk sector size");
 
-  if (!(gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
-	gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID))
-    return grub_error (GRUB_ERR_BUG, "No valid GPT entries");
-
-  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+  if (grub_gpt_primary_valid (gpt))
     {
-      grub_dprintf ("gpt", "primary GPT header is valid\n");
+      grub_dprintf ("gpt", "primary GPT is valid\n");
       backup_header = grub_le_to_cpu64 (gpt->primary.alternate_lba);
       grub_memcpy (&gpt->backup, &gpt->primary, sizeof (gpt->backup));
     }
-  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+  else if (grub_gpt_backup_valid (gpt))
     {
-      grub_dprintf ("gpt", "backup GPT header is valid\n");
+      grub_dprintf ("gpt", "backup GPT is valid\n");
       backup_header = grub_le_to_cpu64 (gpt->backup.header_lba);
       grub_memcpy (&gpt->primary, &gpt->backup, sizeof (gpt->primary));
     }
   else
-    return grub_error (GRUB_ERR_BUG, "No valid GPT header");
+    return grub_error (GRUB_ERR_BUG, "No valid GPT");
 
   /* Relocate backup to end if disk whenever possible.  */
   if (grub_gpt_disk_size_valid(disk))
From 27fcd95383567f5f1c1b0760b8a1d7e528e2a802 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 13:52:52 -0700
Subject: [PATCH] gpt: be more careful about relocating backup header

The header was being relocated without checking the new location is
actually safe. If the BIOS thinks the disk is smaller than the OS then
repair may relocate the header into allocated space, failing the final
validation check. So only move it if the disk has grown.

Additionally, if the backup is valid then we can assume its current
location is good enough and leave it as-is.
---
 grub-core/lib/gpt.c | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 3c6ff3540..35e65d8d9 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -599,7 +599,17 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   if (grub_gpt_primary_valid (gpt))
     {
       grub_dprintf ("gpt", "primary GPT is valid\n");
+
+      /* Relocate backup to end if disk if the disk has grown.  */
       backup_header = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+      if (grub_gpt_disk_size_valid (disk) &&
+	  disk->total_sectors - 1 > backup_header)
+	{
+	  backup_header = disk->total_sectors - 1;
+	  grub_dprintf ("gpt", "backup GPT header relocated to 0x%llx\n",
+			(unsigned long long) backup_header);
+	}
+
       grub_memcpy (&gpt->backup, &gpt->primary, sizeof (gpt->backup));
     }
   else if (grub_gpt_backup_valid (gpt))
@@ -611,12 +621,6 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   else
     return grub_error (GRUB_ERR_BUG, "No valid GPT");
 
-  /* Relocate backup to end if disk whenever possible.  */
-  if (grub_gpt_disk_size_valid(disk))
-    backup_header = disk->total_sectors - 1;
-  grub_dprintf ("gpt", "backup GPT header will be located at 0x%llx\n",
-		(unsigned long long) backup_header);
-
   backup_entries = backup_header -
     grub_gpt_size_to_sectors (gpt, gpt->entries_size);
   grub_dprintf ("gpt", "backup GPT entries will be located at 0x%llx\n",
From eac47a495c3994aecbb66d12b90057dc2e51bde5 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 14:33:48 -0700
Subject: [PATCH] gpt: selectively update fields during repair

Just a little cleanup/refactor to skip touching data we don't need to.
---
 grub-core/lib/gpt.c | 28 ++++++++++++----------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 35e65d8d9..03e807b25 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -584,8 +584,6 @@ grub_gpt_get_partentry (grub_gpt_t gpt, grub_uint32_t n)
 grub_err_t
 grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 {
-  grub_uint64_t backup_header, backup_entries;
-
   /* Skip if there is nothing to do.  */
   if (grub_gpt_both_valid (gpt))
     return GRUB_ERR_NONE;
@@ -598,6 +596,8 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 
   if (grub_gpt_primary_valid (gpt))
     {
+      grub_uint64_t backup_header;
+
       grub_dprintf ("gpt", "primary GPT is valid\n");
 
       /* Relocate backup to end if disk if the disk has grown.  */
@@ -608,32 +608,28 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 	  backup_header = disk->total_sectors - 1;
 	  grub_dprintf ("gpt", "backup GPT header relocated to 0x%llx\n",
 			(unsigned long long) backup_header);
+
+	  gpt->primary.alternate_lba = grub_cpu_to_le64 (backup_header);
 	}
 
       grub_memcpy (&gpt->backup, &gpt->primary, sizeof (gpt->backup));
+      gpt->backup.header_lba = gpt->primary.alternate_lba;
+      gpt->backup.alternate_lba = gpt->primary.header_lba;
+      gpt->backup.partitions = grub_cpu_to_le64 (backup_header -
+	  grub_gpt_size_to_sectors (gpt, gpt->entries_size));
     }
   else if (grub_gpt_backup_valid (gpt))
     {
       grub_dprintf ("gpt", "backup GPT is valid\n");
-      backup_header = grub_le_to_cpu64 (gpt->backup.header_lba);
+
       grub_memcpy (&gpt->primary, &gpt->backup, sizeof (gpt->primary));
+      gpt->primary.header_lba = gpt->backup.alternate_lba;
+      gpt->primary.alternate_lba = gpt->backup.header_lba;
+      gpt->primary.partitions = grub_cpu_to_le64_compile_time (2);
     }
   else
     return grub_error (GRUB_ERR_BUG, "No valid GPT");
 
-  backup_entries = backup_header -
-    grub_gpt_size_to_sectors (gpt, gpt->entries_size);
-  grub_dprintf ("gpt", "backup GPT entries will be located at 0x%llx\n",
-		(unsigned long long) backup_entries);
-
-  /* Update/fixup header and partition table locations.  */
-  gpt->primary.header_lba = grub_cpu_to_le64_compile_time (1);
-  gpt->primary.alternate_lba = grub_cpu_to_le64 (backup_header);
-  gpt->primary.partitions = grub_cpu_to_le64_compile_time (2);
-  gpt->backup.header_lba = gpt->primary.alternate_lba;
-  gpt->backup.alternate_lba = gpt->primary.header_lba;
-  gpt->backup.partitions = grub_cpu_to_le64 (backup_entries);
-
   /* Recompute checksums.  */
   if (grub_gpt_update_checksums (gpt))
     return grub_errno;
From dab5d9e809c0cea5c6b5d0f5ba093068465fe1cb Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 14:55:19 -0700
Subject: [PATCH] gpt: always revalidate when recomputing checksums

This ensures all code modifying GPT data include the same sanity check
that repair does. If revalidation fails the status flags are left in the
appropriate state.
---
 grub-core/lib/gpt.c | 32 ++++++++++++++++++--------------
 1 file changed, 18 insertions(+), 14 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 03e807b25..3ac2987c6 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -630,23 +630,9 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   else
     return grub_error (GRUB_ERR_BUG, "No valid GPT");
 
-  /* Recompute checksums.  */
   if (grub_gpt_update_checksums (gpt))
     return grub_errno;
 
-  /* Sanity check.  */
-  if (grub_gpt_check_primary (gpt))
-    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
-
-  gpt->status |= (GRUB_GPT_PRIMARY_HEADER_VALID |
-		  GRUB_GPT_PRIMARY_ENTRIES_VALID);
-
-  if (grub_gpt_check_backup (gpt))
-    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
-
-  gpt->status |= (GRUB_GPT_BACKUP_HEADER_VALID |
-		  GRUB_GPT_BACKUP_ENTRIES_VALID);
-
   grub_dprintf ("gpt", "repairing GPT for %s successful\n", disk->name);
 
   return GRUB_ERR_NONE;
@@ -657,6 +643,12 @@ grub_gpt_update_checksums (grub_gpt_t gpt)
 {
   grub_uint32_t crc;
 
+  /* Clear status bits, require revalidation of everything.  */
+  gpt->status &= ~(GRUB_GPT_PRIMARY_HEADER_VALID |
+		   GRUB_GPT_PRIMARY_ENTRIES_VALID |
+		   GRUB_GPT_BACKUP_HEADER_VALID |
+		   GRUB_GPT_BACKUP_ENTRIES_VALID);
+
   /* Writing headers larger than our header structure are unsupported.  */
   gpt->primary.headersize =
     grub_cpu_to_le32_compile_time (sizeof (gpt->primary));
@@ -670,6 +662,18 @@ grub_gpt_update_checksums (grub_gpt_t gpt)
   grub_gpt_header_lecrc32 (&gpt->primary.crc32, &gpt->primary);
   grub_gpt_header_lecrc32 (&gpt->backup.crc32, &gpt->backup);
 
+  if (grub_gpt_check_primary (gpt))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
+
+  gpt->status |= (GRUB_GPT_PRIMARY_HEADER_VALID |
+		  GRUB_GPT_PRIMARY_ENTRIES_VALID);
+
+  if (grub_gpt_check_backup (gpt))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
+
+  gpt->status |= (GRUB_GPT_BACKUP_HEADER_VALID |
+		  GRUB_GPT_BACKUP_ENTRIES_VALID);
+
   return GRUB_ERR_NONE;
 }
 
From de5adec64e3b72c79b08b398f24152e84ab89b5f Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 15:01:09 -0700
Subject: [PATCH] gpt: include backup-in-sync check in revalidation

---
 grub-core/lib/gpt.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 3ac2987c6..c27bcc510 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -372,6 +372,11 @@ grub_gpt_check_backup (grub_gpt_t gpt)
   if (backup <= end)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
 
+  /* If both primary and backup are valid but differ prefer the primary.  */
+  if ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) &&
+      !grub_gpt_headers_equal (gpt))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "backup GPT out of sync");
+
   return GRUB_ERR_NONE;
 }
 
@@ -435,11 +440,6 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
   if (grub_le_to_cpu64 (gpt->backup.header_lba) != sector)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
 
-  /* If both primary and backup are valid but differ prefer the primary.  */
-  if ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) &&
-      !grub_gpt_headers_equal(gpt))
-    return grub_error (GRUB_ERR_BAD_PART_TABLE, "backup GPT of of sync");
-
   gpt->status |= GRUB_GPT_BACKUP_HEADER_VALID;
   return GRUB_ERR_NONE;
 }
From 7b0ccb8fcc584be82e3f4778aad8afe512468f3b Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 15:29:55 -0700
Subject: [PATCH] gpt: read entries table at the same time as the header

I personally think this reads easier. Also has the side effect of
directly comparing the primary and backup tables instead of presuming
they are equal if the crc32 matches.
---
 grub-core/lib/gpt.c | 69 +++++++++++++++++++++++++++++++----------------------
 1 file changed, 41 insertions(+), 28 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index c27bcc510..b93cedea1 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -32,6 +32,11 @@ GRUB_MOD_LICENSE ("GPLv3+");
 
 static grub_uint8_t grub_gpt_magic[] = GRUB_GPT_HEADER_MAGIC;
 
+static grub_err_t
+grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
+		       struct grub_gpt_header *header,
+		       void **ret_entries,
+		       grub_size_t *ret_entries_size);
 
 char *
 grub_gpt_guid_to_str (grub_gpt_guid_t *guid)
@@ -400,12 +405,21 @@ grub_gpt_read_primary (grub_disk_t disk, grub_gpt_t gpt)
     return grub_errno;
 
   gpt->status |= GRUB_GPT_PRIMARY_HEADER_VALID;
+
+  if (grub_gpt_read_entries (disk, gpt, &gpt->primary,
+			     &gpt->entries, &gpt->entries_size))
+    return grub_errno;
+
+  gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
+
   return GRUB_ERR_NONE;
 }
 
 static grub_err_t
 grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
 {
+  void *entries = NULL;
+  grub_size_t entries_size;
   grub_uint64_t sector;
   grub_disk_addr_t addr;
 
@@ -441,12 +455,35 @@ grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
 
   gpt->status |= GRUB_GPT_BACKUP_HEADER_VALID;
+
+  if (grub_gpt_read_entries (disk, gpt, &gpt->backup,
+			     &entries, &entries_size))
+    return grub_errno;
+
+  if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID)
+    {
+      if (entries_size != gpt->entries_size ||
+	  grub_memcmp (entries, gpt->entries, entries_size) != 0)
+	return grub_error (GRUB_ERR_BAD_PART_TABLE, "backup GPT out of sync");
+
+      grub_free (entries);
+    }
+  else
+    {
+      gpt->entries = entries;
+      gpt->entries_size = entries_size;
+    }
+
+  gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
+
   return GRUB_ERR_NONE;
 }
 
 static grub_err_t
 grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
-		       struct grub_gpt_header *header)
+		       struct grub_gpt_header *header,
+		       void **ret_entries,
+		       grub_size_t *ret_entries_size)
 {
   void *entries = NULL;
   grub_uint32_t count, size, crc;
@@ -488,9 +525,8 @@ grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
       goto fail;
     }
 
-  grub_free (gpt->entries);
-  gpt->entries = entries;
-  gpt->entries_size = entries_size;
+  *ret_entries = entries;
+  *ret_entries_size = entries_size;
   return GRUB_ERR_NONE;
 
 fail:
@@ -529,30 +565,7 @@ grub_gpt_read (grub_disk_t disk)
     grub_gpt_read_backup (disk, gpt);
 
   /* If either succeeded clear any possible error from the other.  */
-  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID ||
-      gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
-    grub_errno = GRUB_ERR_NONE;
-  else
-    goto fail;
-
-  /* Similarly, favor the value or error from the primary table.  */
-  if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID &&
-      !grub_gpt_read_entries (disk, gpt, &gpt->backup))
-    {
-      grub_dprintf ("gpt", "read valid backup GPT from %s\n", disk->name);
-      gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
-    }
-
-  grub_errno = GRUB_ERR_NONE;
-  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID &&
-      !grub_gpt_read_entries (disk, gpt, &gpt->primary))
-    {
-      grub_dprintf ("gpt", "read valid primary GPT from %s\n", disk->name);
-      gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
-    }
-
-  if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
-      gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID)
+  if (grub_gpt_primary_valid (gpt) || grub_gpt_backup_valid (gpt))
     grub_errno = GRUB_ERR_NONE;
   else
     goto fail;
From ff51b717a6122c2811fe221dd65a29a03dcef347 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Wed, 21 Sep 2016 16:02:53 -0700
Subject: [PATCH] gpt: report all revalidation errors

Before returning an error that the primary or backup GPT is invalid push
the existing error onto the stack so the user will be told what is bad.
---
 grub-core/lib/gpt.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index b93cedea1..f6f853309 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -676,13 +676,19 @@ grub_gpt_update_checksums (grub_gpt_t gpt)
   grub_gpt_header_lecrc32 (&gpt->backup.crc32, &gpt->backup);
 
   if (grub_gpt_check_primary (gpt))
-    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
+    {
+      grub_error_push ();
+      return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
+    }
 
   gpt->status |= (GRUB_GPT_PRIMARY_HEADER_VALID |
 		  GRUB_GPT_PRIMARY_ENTRIES_VALID);
 
   if (grub_gpt_check_backup (gpt))
-    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
+    {
+      grub_error_push ();
+      return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
+    }
 
   gpt->status |= (GRUB_GPT_BACKUP_HEADER_VALID |
 		  GRUB_GPT_BACKUP_ENTRIES_VALID);
From 4eb61a681cd1f4217dd19903b67c8fb141eafd82 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 22 Sep 2016 10:00:27 -0700
Subject: [PATCH] gpt: rename and update documentation for grub_gpt_update

The function now does more than just recompute checksums so give it a
more general name to reflect that.
---
 grub-core/commands/gptprio.c | 2 +-
 grub-core/lib/gpt.c          | 4 ++--
 include/grub/gpt_partition.h | 7 ++++---
 3 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
index a439552e1..4a24fa62d 100644
--- a/grub-core/commands/gptprio.c
+++ b/grub-core/commands/gptprio.c
@@ -127,7 +127,7 @@ grub_find_next (const char *disk_name,
 
       grub_gptprio_set_tries_left (part_found, tries_left - 1);
 
-      if (grub_gpt_update_checksums (gpt))
+      if (grub_gpt_update (gpt))
 	goto done;
 
       if (grub_gpt_write (dev->disk, gpt))
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index f6f853309..430404848 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -643,7 +643,7 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
   else
     return grub_error (GRUB_ERR_BUG, "No valid GPT");
 
-  if (grub_gpt_update_checksums (gpt))
+  if (grub_gpt_update (gpt))
     return grub_errno;
 
   grub_dprintf ("gpt", "repairing GPT for %s successful\n", disk->name);
@@ -652,7 +652,7 @@ grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
 }
 
 grub_err_t
-grub_gpt_update_checksums (grub_gpt_t gpt)
+grub_gpt_update (grub_gpt_t gpt)
 {
   grub_uint32_t crc;
 
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index ee435d73b..4730fe362 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -232,11 +232,12 @@ grub_gpt_t grub_gpt_read (grub_disk_t disk);
 struct grub_gpt_partentry * grub_gpt_get_partentry (grub_gpt_t gpt,
 						    grub_uint32_t n);
 
-/* Sync up primary and backup headers, recompute checksums.  */
+/* Sync and update primary and backup headers if either are invalid.  */
 grub_err_t grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt);
 
-/* Recompute checksums, must be called after modifying GPT data.  */
-grub_err_t grub_gpt_update_checksums (grub_gpt_t gpt);
+/* Recompute checksums and revalidate everything, must be called after
+ * modifying any GPT data.  */
+grub_err_t grub_gpt_update (grub_gpt_t gpt);
 
 /* Write headers and entry tables back to disk.  */
 grub_err_t grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt);
From 313d88eab9e5c11a168c45978feccdd52b5ec6e5 Mon Sep 17 00:00:00 2001
From: Michael Marineau <michael.marineau@coreos.com>
Date: Thu, 22 Sep 2016 11:18:42 -0700
Subject: [PATCH] gpt: write backup GPT first, skip if inaccessible.

Writing the primary GPT before the backup may lead to a confusing
situation: booting a freshly updated system could consistently fail and
next boot will fall back to the old system if writing the primary works
but writing the backup fails. If the backup is written first and fails
the primary is left in the old state so the next boot will re-try and
possibly fail in the exact same way. Making that repeatable should make
it easier for users to identify the error.

Additionally if the firmware and OS disagree on the disk size, making
the backup inaccessible to GRUB, then just skip writing the backup.
When this happens the automatic call to `coreos-setgoodroot` after boot
will take care of repairing the backup.
---
 grub-core/lib/gpt.c | 28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
index 430404848..c3e3a25f9 100644
--- a/grub-core/lib/gpt.c
+++ b/grub-core/lib/gpt.c
@@ -729,19 +729,39 @@ grub_gpt_write_table (grub_disk_t disk, grub_gpt_t gpt,
 grub_err_t
 grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt)
 {
+  grub_uint64_t backup_header;
+
   /* TODO: update/repair protective MBRs too.  */
 
   if (!grub_gpt_both_valid (gpt))
     return grub_error (GRUB_ERR_BAD_PART_TABLE, "Invalid GPT data");
 
+  /* Write the backup GPT first so if writing fails the update is aborted
+   * and the primary is left intact.  However if the backup location is
+   * inaccessible we have to just skip and hope for the best, the backup
+   * will need to be repaired in the OS.  */
+  backup_header = grub_le_to_cpu64 (gpt->backup.header_lba);
+  if (grub_gpt_disk_size_valid (disk) &&
+      backup_header >= disk->total_sectors)
+    {
+      grub_printf ("warning: backup GPT located at 0x%llx, "
+		   "beyond last disk sector at 0x%llx\n",
+		   (unsigned long long) backup_header,
+		   (unsigned long long) disk->total_sectors - 1);
+      grub_printf ("warning: only writing primary GPT, "
+	           "the backup GPT must be repaired from the OS\n");
+    }
+  else
+    {
+      grub_dprintf ("gpt", "writing backup GPT to %s\n", disk->name);
+      if (grub_gpt_write_table (disk, gpt, &gpt->backup))
+	return grub_errno;
+    }
+
   grub_dprintf ("gpt", "writing primary GPT to %s\n", disk->name);
   if (grub_gpt_write_table (disk, gpt, &gpt->primary))
     return grub_errno;
 
-  grub_dprintf ("gpt", "writing backup GPT to %s\n", disk->name);
-  if (grub_gpt_write_table (disk, gpt, &gpt->backup))
-    return grub_errno;
-
   return GRUB_ERR_NONE;
 }
 
From 290b82244de9e527ced46a9a04e2f7c6817f51e5 Mon Sep 17 00:00:00 2001
From: iliana destroyer of worlds <iweller@amazon.com>
Date: Thu, 28 Mar 2019 16:28:41 -0700
Subject: [PATCH] Generate new gptprio partition type

Signed-off-by: iliana destroyer of worlds <iweller@amazon.com>
---
 include/grub/gpt_partition.h | 4 ++--
 tests/gptprio_test.in        | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 4730fe362..438d983a6 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -62,8 +62,8 @@ char * grub_gpt_guid_to_str (grub_gpt_guid_t *guid);
       0x85, 0xd2, 0xe1, 0xe9, 0x04, 0x34, 0xcf, 0xb3)
 
 #define GRUB_GPT_PARTITION_TYPE_USR_X86_64 \
-  GRUB_GPT_GUID_INIT (0x5dfbf5f4, 0x2848, 0x4bac, \
-      0xaa, 0x5e, 0x0d, 0x9a, 0x20, 0xb7, 0x45, 0xa6)
+  GRUB_GPT_GUID_INIT (0x6b636168, 0x7420, 0x6568, \
+      0x20, 0x70, 0x6c, 0x61, 0x6e, 0x65, 0x74, 0x21)
 
 #define GRUB_GPT_HEADER_MAGIC \
   { 0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54 }
diff --git a/tests/gptprio_test.in b/tests/gptprio_test.in
index c5cf0f3b7..325627546 100644
--- a/tests/gptprio_test.in
+++ b/tests/gptprio_test.in
@@ -59,7 +59,7 @@ esac
 img1="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
 trap "rm -f '${img1}'" EXIT
 
-prio_type="5dfbf5f4-2848-4bac-aa5e-0d9a20b745a6"
+prio_type="6b636168-7420-6568-2070-6c616e657421"
 declare -a prio_uuid
 prio_uuid[2]="9b003904-d006-4ab3-97f1-73f547b7af1a"
 prio_uuid[3]="1aa5a658-5b02-414d-9b71-f7e6c151f0cd"
